### 스택의 선언 
```
Stack<Integer> st = new Stack<Integer>();
```

### 스택
```
st.push();
st.pop();
st.size();
```
바로 문제에 적용해보자 boj 1259번 문제를 보면 팰린드롬 문제이다.
물론 스택을 이용해서 풀지 않아도 되지만, 배웠으므로 머리에 남게 사용해보자.

```
생략
Stack<Integer> sa = new Stack<Integer>();
		Queue<Integer> qu = new LinkedList<Integer>();
		
		while(true) {
			int N = Integer.parseInt(br.readLine());
			if(N == 0)break;
			//정수를 문자열로 받기 
			String input = Integer.toString(N); 
			for(char c : input.toCharArray()) {
				int num = Character.getNumericValue(c);
				sa.add(num);
				qu.add(num);
			}
			//같은게 나오는지 확인하는 로직 
			boolean isSame = true;
			while(!sa.isEmpty()) {
				if(sa.pop().intValue() != qu.poll().intValue()) {
					isSame = false;
					break;
					}
			}
		
			if(isSame) {
					System.out.println("yes");
				}else {
					System.out.println("no");
				}
			sa.clear();
			qu.clear();
			}
		}
			
	}
```

121
1231
12421
0     입력은 이렇게 된다.

처음부터 각 줄을 문자열로 받고, 이를 하나의 문자(char)로 쪼갠다. 이를 각각 스택과 큐에 넣는다.
LIFO 와 FIFO의 성질을 이용, 나오는게 다를 경우 팰린드롬이 아니라고 판단한다. 


###큐
큐의 선언 자바에서 큐는 FIFO선입선출이다. 
```
Queue<자료형> qu = new Queue가 아니라 LinkedList로 구현된다 즉,
Queue<자료형> qu = new LinkedList<자료형>();


qu.offer(); 요소 추가 add도 가능
qu.poll(); 첫번째 값을 반환 후 제거
qu.peek(); 첫번째 값 단순 참조 
```
### 우선순위 큐

FIFO가 아니라, 우선순위를 정해서 우선순위 요소가 먼저 나가는 큐이다. 힙으로 구성되어 이진트리 구조로 이루어져있다.
시간복잡도는 O(nlogn) 이다.

어디에 쓰일까? 응급실과 같이 우선순위를 중요시해야 하는 상황에서 쓰인다. 
```
PriorityQueue<자료형> pq = new PriorityQueue<자료형>();
//우선순위가 낮은 숫자 순 높은 숫자 순은
PriorityQueue<>(Collections.reverseOrder()); 이다.
```
우선순위큐도 마찬가지로
pq.add(); 요소추가
pq.poll(); 할 때 비교연산자 comparable이 구현되지 않으면 classcast예외가 발생한다.
이때, 클래스에 Comparable인터페이스를 구현하거나, PriorityQueue 생성시에 Comparator를 매개변수로 넣어주거나, 매개변수에 람다식을 작성하는 방식으로 우선순위를 지정해 줄 수있다.

기본으로 한다면 가장 낮은 숫자가 가장 위에서부터 나타난다. 

### 이진트리 개념이 나왔다 이것은 무엇인가?

graph의 일종 일반적인 트리와 구분된다. 각 노드의 자식 수가 2 이하인 트리이다.
계층적 자료구조로 배열이나 연결리스트의 단점을 보완하는 자료구조. 

효율적인 삽입과 탐색이 가능
포화이진트리 : 각 내부노드가 2개의 자식노드를 가지는 트리
완전이진트리 : 마지막 레벨을 제외한 각 레벨이 노드들로 꽉 차있고, 마지막 레벨에는 노드들이 왼쪽부터 빠짐없이 채워진 트리.

### 순환방식
각 노드를 반드시 한번씩 방문해야 순회가 종료 
1. 전위 : 
2. 중위 :
3. 후위 : 
4. 레벨 순회   순회는 각 노드들을 방문해야 하므로 각각 o(N)시간이 소요된다. 
```
pq.size() 노드 수 계산
pq.height() 트리의 높이 계산 이 두개는 후위순회에 기반
pq.isEqual() 은 전위순회에 기반 
```

## 정렬

### 선택정렬
아직 정렬되지 않은 부분의 원소 중에서 '최솟값'을 선택하여 정렬된 부분의 바로 오른쪽 원소와 교환하는 정렬 알고리즘 

```
import java.lang.Comparable;
public class Selection {
	public static void sort(Comparable[] a ){
		int N = a.length;
		for(int i = 0; i< N; i++){
			int min = i;
			for(int j = i+1; j < N; j++){
				if(isless(a[j], a[min])) min = j;
			}
			swap(a, i, min);
		}
	}
	private static boolean isless(Comparable i, Comparable j) {
		return(i.compareTo(j< 0); //i.comparTo(j) < 0 이라는 것은 즉 j가 더 큰경우이다. 
	}
	private static void swap(Comparable[] a, int i, int j){
		Comparable tmep = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
}
```
정렬된 부분 바로 다음원소가 i번째 원소이고 정렬된 부분이후 중 가장 최솟값이 min
min과 i를 교환한다. 
시간복잡도는 이중반복문에 n-1, n-2번 방문하기 때문에 항상 o(n^2)이다. 
정렬 알고리즘들중 가장 작은 최악경우 교환횟수. 그럼에도 불구하고, 효율성 측면에서 뒤떨어져 거의 활용되지 않는다.

### 삽입정렬

배열이 정렬된 부분과 정렬되지 않은 부분으로 나뉘며, 정렬이 안된 부분의 가장 왼쪽 원소를 정렬된 부분에 삽입하는 방식의 정렬알고리즘이다. 
```
import java.lang.Comparable;
public class Insertion{
	public static void sort(Comparable[] a){
		int N = a.length;
		for(int i = 1; i < N; i++{
			for(int j = i; j > 0; j--){
				if(isless(a[j], a[k-1]))
					swap(a, j, j-1);
				else break;
			}
		}
	}
}
```
최선의 경우 n-1 비교로 정렬 끝, 최악의 경우 o(n^2) 
입력이 거의 정렬된 경우 우수한 성능을 보인다. 

### 쉘 정렬

삽입 정렬에 전처리과정을 추가한 것
전처리과정이란 작은 값을 가진 원소들을 배열의 앞부분으로 옮기며 큰 값을 가진 원소들이 배열의 뒷부분에 자리잡도록 만드는 과정 

h정렬수행 h =4 라면 배열 []a 에서 a[4]와 a[4-4]와 비교한다. 
a[5], a[1]와 비교
조건식의 특이성으로 j >= h이기 때문에 a[8]과 a[4]와 비교하고 a[4]와 a[0]도 비교하는 작업이 이루어진다.
그 다음처럼 i = 10일 때 a[10]과 a[6]을 비교, a[6]과 a[2]를 비교한다.  

for반복문 탈출시 h /= 3 으로 h=1로 만든다. 
h=1인 경우는 삽입정렬과 동일하다. 

p.s 소문자의 아스키 코드값은 대문자보다 크기 때문에 뒤에 정렬된다. sort하면

쉘정렬은 임베디드 시스템에서 주로 사용된다. 

### 힙정렬

힙 자료구조를 이용하는 정렬 힙에는 두 종류가 있다. 최소힙과 최대힙
배열에 저장된 데이터의 키를 우선순위로 하는 최대힙으로 구성한다. 루트가 가장 큰 최대값을 가진다. 
루트노드의 숫자를 힙의 가장 마지막 노드에 있는 숫자와 교환, 힙 크기를 1 감소시킨다.
위배된 최대힙 속성을 downheap 연산으로 복원한다. 

공백에 대한 아스키 코드값은 32의 값을 가진다. 대문자 A는 65의 값을 가진다. 힙정렬에서 a[0]을 사용하지 않아서,
임의적으로 공백을 추가를 한 것이다. 예를 들어 소문자 a를 a[0]에 넣으면, 소문자 a는 정렬출력되지 않는다. 

수행시간 
상향식 힙 구성 o(n)시간 루트와 마지막 노드 교환 후 downheap 수행 o(logN) 시간, 이를 교환하는 횟수 n-1번
o(n) + (n-1) * o(NlogN)

루프 내의 코드가 길고, 비효율적인 캐시메모리 사용에 따라 대용량의 입력을 정렬하기에 부적절. 

 ### 합병정렬

 합병정렬은 크기가 N인 입력을 n/2크기를 갖는 입력 2개로 분할하고, 각각에 대해 재귀적으로 합병정렬을 수행한 후, 2개의 각각 정렬된 부분을 합병하는 정렬알고리즘이다.  합병이란 합치는 동시에 정렬을 하는 과정 

합병정렬도 분할정복 알고리즘 중 하나이다.  각각 정렬할 때 재귀호출을 이용한다.
재귀호출에 의해 8개가 4,4로 나뉘면 또 4개를 2,2로 나눈다. 2 크기도 1,1로 나눈다. 더 나눌수 없기 때문에 합병한다.
합병하고 return이 되어서 바로 윗단계로 넘어간다. 합병하면서 정렬하는 것임. 

어떤 수행에도 o(nlogn) 걸린다 

### 퀵정렬

입력의 맨 왼쪽 원소{선정방법은 여러개 있다}(피벗)을 기준으로 피벗보다 작은 원소들과 큰 원소들을 각각 피벗의 좌우로 분할한 후, 피벗보다 작은 원소들과 피벗보다 큰 원소들을 각각 재귀적으로 정렬하는 알고리즘  

최선경우 (피벗이 중앙에 놓이는 경우) 합병정렬의 수행시간과 동일  평균 o(nlogn)  최악경우 o(n^2) (피벗이 매번 가장 작거나 클 경우)


### 그럼 Arrays.sort가 있는데 이런 알고리즘이 왜 있는가?
여러가지 이유가 있다 
1. 경우에 따라 다른 알고리즘이 효율적일 때도 있기 때문이다. 예를 들면, 합병정렬은 항상 o(nlog n)이 걸리기 때문에 더 빠를 때가 있다.

2. 구현의 단순성 및 효율성의 차이 예를 들면 퀵 정렬은 구현이 비교적 간단하고, 평균적으로 매우 빠르지만, 병합 정렬은 구현이 복잡하지만, 항상 일정한 성능을 보장한다.

3. 공간복잡도 퀵 정렬은 제자리 정렬이 가능하여 추가 메모리가 거의 필요하지 않습니다. 하지만 병합 정렬은 추가 메모리가 필요하다

4. 1의 확장 퀵 정렬은 이미 정렬된 배열에 대해서는 비효율적일 수 있다. 무작위 데이터에 유리. 병합 정렬은 큰 데이터 큰 데이터셋이나 안정적인 정렬이 필요한 경우 유리하다.

5. 안정성  안정 정렬은 같은 값이 있을 때 원래의 순서를 유지. 퀵 정렬은 불안정, 병합은 안정정렬이다.  
현재 java 21버전은 기본 정렬 알고리즘으로 이중피벗퀵정렬을 사용한다. 이중피벗퀵정렬은 피벗을 두 개 사용하여 배열을 세 부분으로 나누기 때문에 일반적인 퀵 정렬보다 더 효율적이다. 

6. 개별 요구사항 실시간 시스템에서는 시간 복잡도가 일정한 알고리즘이 선호될 수 있다. 대용량 데이터의 외부 정렬에서는 병합 정렬이 주로 사용된다.

현재 java 21은 이중피벗퀵정렬을 기본 정렬 알고리즘으로 사용하고 있다. 일반적인 퀵 정렬의 변형으로 두 개의 피벗을 사용하여 배열을 세 부분으로 분할한다. 

시간복잡도 평균 o(nlog n) 최악 o(n^2)
공간복잡도 제자리 정렬이기때문에 추가 메모리 사용이 적다. 
