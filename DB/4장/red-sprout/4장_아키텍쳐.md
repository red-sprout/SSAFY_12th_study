# MySQL 엔진 아키텍쳐

## MySQL 전체 구조

![1](https://github.com/user-attachments/assets/fd3c14aa-df70-4255-9f9b-7c185b83948b)

- MySQL 서버 = MySQL 엔진 + 스토리지 엔진

### MySQL 엔진

💡요청된 SQL 문장을 분석하거나 최적화 - DBMS의 두뇌

- 커넥션 핸들러(Connection Handler) : 클라이언트로부터의 접속 및 쿼리 요청 처리
- SQL 파서, 전처리기(Parser)
- 옵티마이저(Optimizer) : 쿼리의 최적화된 실행

### 스토리지 엔진

💡실제 데이터를 디스크 스토리지에 저장하거나 이로부터 데이터를 읽는 역할

- MySQL 엔진은 하나, 스토리지 엔진은 여러 개 사용 가능
- 각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM 스토리지 엔진)나 InnoDB 버퍼 풀(InnoDB 스토리지 엔진)과 같은 기능을 내장

### 핸들러 API

- `핸들러 요청` : MySQL 엔진의 쿼리 실행기에서 데이터를 읽거나 쓸 때 각 스토리지 엔진에 읽기 또는 쓰기를 요청
- 이러한 API 활용 얼마나 많은 작업 있는지 확인
    
    ```sql
    SHOW GLOBAL STATUS LIKE 'Handler%';
    ```
    

## MySQL 스레딩 구조

![2](https://github.com/user-attachments/assets/18ce67a9-ef5b-41c2-80d7-a8a2c1947c87)

- MySQL 서버는 프로세스가 아닌 **스레드 기반으로 작동**
- 크게 **포그라운드(Foreground) 스레드**와 **백그라운드(Background) 스레드**로 구분

### 포그라운드 스레드(클라이언트 스레드)

- 최소 MySQL 서버 접속 클라이언트 수만큼 존재
- 각 클라이언트가 요청하는 쿼리 처리
- 커넥션 종료시 해당 스레드는 스레드 캐시로 되돌아감
    - 바로 스레드가 사라지는 것이 아닌 스레드 캐시에 최근에 연결이 종료된 몇 개의 스레드 위치
    - MyISAM의 경우에 디스크 쓰기 작업까지 포그라운드가 처리
    - InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드가 처리하고 나머지는 백그라운드

### 백그라운드 스레드

- InnoDB의 경우 다음과 같은 작업들은 포함
    - 인서트 버퍼를 병합하는 스레드
    - **로그를 디스크로 기록하는 스레드**
    - **InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드**
    - 데이터를 버퍼로 읽어오는 스레드
    - 잠금이나 데드락을 모니터링하는 스레드
- 사용자 요청 처리 도중 - 쓰기는 lazy 하게 가능, 읽기는 지연 불가능

## 메모리 할당 및 사용 구조

### 글로벌 메모리 영역

- 클라이언트와 무관하게 하나의 메모리 공간만 할당
- 대표적인 글로벌 메모리 영역
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼

### 로컬 메모리 영역

- 세션 메모리 영역, 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용함
- 클라이언트가 MySQL 서버 접속 시 MySQL 서버에서는 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 할당
- 절대 공유되어 사용되지 않음
- 로컬 메모리 공간을 크게 신경 쓰지 않고 설정 - 적절한 메모리 공간 설정이 중요
- 대표적인 로컬 메모리 영역
    - 정렬 버퍼(Sort buffer)
    - 조인 버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼

## 플러그인 스토리지 엔진 모델

- 쿼리 실행되는 과정은 거의 대부분 작업이 MySQL 엔진에서 처리, 마지막 읽기 / 쓰기만 스토리지 엔진에서 처리
    - SQL 파서 → SQL 옵티마이저 → SQL 실행기 순으로 MySQL 엔진에서 처리
- `SHOW ENGINE` : 현재 설치된 서버가 지원하는 스토리지 엔진 확인

![3](https://github.com/user-attachments/assets/767c50b8-9cba-4388-a4b1-7e8fbaabe023)

- Support 칼럼에 표시될 수 있는 값
    - `YES` : MySQL 서버 포함, 사용 기능으로 활성화
    - `DEFAULT` : MySQL 서버 포함, 필수 스토리지 엔진
    - `NO` : MySQL 서버에 포함되지 않음
    - `DISABLED` : MySQL 서버 포함, 비활성화
- `SHOW PLUGINS` : 플러그인 확인

![4](https://github.com/user-attachments/assets/9f4cd98f-1405-43f3-b1dc-225944a59a5c)

## 컴포넌트

- 플러그인의 단점 → 컴포넌트 사용
    - 오직 MySQL 서버와만 통신, 플러그인끼리는 통신 불가능
    - MySQL 서버의 변수나 함수를 직접 호출하기에 안전하지 않음(캡슐화 X)
    - 상호 의존 관계 설정 불가능

## 쿼리 실행 구조

### 쿼리 파서

- 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업
- 쿼리 문장의 기본적인 문법 오류는 여기서 발견, 오류 메시지 전달

### 전처리기

- 파서 트리 기반으로 쿼리 문장에 구조적인 문제점이 있는지를 확인
- 실제 존재하지 않거나 권한에 막힌 토근은 이 단계에서 필터링

### 옵티마이저

- 어떻게 쿼리 문장을 빠르게 처리할 지 결정하는 역할, **DBMS의 두뇌**

### 실행 엔진

- 실제 동작과 관련 있음
    - 옵티마이저가 GROUP BY 처리하기 위해 임시테이블을 사용한다고 가장
    
    ```
    1. 실행 엔진이 핸들러에게 임시 테이블을 만들라 요청
    2. 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
    3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
    4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
    5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김
    ```
    

### 핸들러(스토리지 엔진)

- MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어 오는 역할

## 트랜잭션 지원 메타데이터

- 데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보
- 8.0 부터는 테이블의 구조 정보나 Stored Program의 코드 관련 정보를 모두 InnoDB의 테이블에 저장하도록 개선

# InnoDB 스토리지 엔진 아키텍쳐

- MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반 잠금을 제공하기에 높은 동시성 처리가 가능

![5](https://github.com/user-attachments/assets/9c19e1a1-02ab-40c5-bfe5-92a29992e7d4)

## Primary 키 클러스터링

- InnoDB의 모든 테이블은 기본적으로 프라이머리 키 기준으로 클러스터링
    - 프라이머리 키 이용한 레인지 스캔은 빠름
- MyISAM 스토리지 엔진에서는 클러스터링 키 지원 X

## 외래 키 지원

- InnoDB 스토리지 엔진 레벨에서 지원하는 기능
- 다만 InnoDB 기준, 외래 키는 부모 및 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 과정에서 양쪽을 모두 확인하는 과정을 거치기 때문에 여러 테이블에 Lock이 전파될 위험이 있음.
    - 만약 시스템 적으로 긴급한 조치가 필요할 경우, `foreign_key_checks` 라는 시스템 변수를 `OFF`로 설정하여 체크 작업을 멈출 수 있음.
    - 이렇게 되면 `CASCADE` 작업도 무사하게 됨

## MVCC(Multi Version Concurrency Control)

- Lock을 사용하지 않는 일관된 읽기를 제공
- Undo log 이용해서 이 기능 구현
- `READ COMMITED` 의 디폴트 Isolation Level이라 가정하자.
    - UPDATE 시 커밋 실행여부 관계 없이 InnoDB의 버퍼 풀은 새로운 값으로 갱신
    - 변경전 값만 Undo log로 복사
    - COMMIT/ROLLBACK 안된 상태에서 다른 사용자가 조회 시
        - Isolation Level 따름
        - READ UNCOMMITED 라면 InnoDB의 버퍼 풀이 갖고 있는 데이터 반환
        - 트랜잭션이 길어지면 Undo 영역이 갖고 있는 데이터가 길어짐
        - Undo의 해당 데이터는 COMMIT 이 아닌 필요한 트랜젝션이 없을 삭제

## 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- InnoDB는 MVCC를 활용하여 Lock을 사용하지 않고 읽기 작업을 수행.
- SERIALIZABLE이 아니면 SELECT의 경우 다른 트랜잭션과 별개로 Lock을 기다리지 않음.
- InnoDB에서는 Undo 영역을 사용
- 트랜잭션이 너무 오래 활성화 되어 있다면 서버가 느려지거나 문제가 발생할 수 있으므로, 트랜잭션이 실행되었다면 커밋이나 롤백을 빨리 하는게 좋음.

## 자동 데드락 감지

- InnoDB는 Lock 대기 목록을 Wait-For List로 관리
    - 데드락 감지 스레드가 주기적으로 이 그래프를 검사하고, Deadlock에 빠지게 되면 하나를 강제 종료
    - Undo 로그의 양이 적은 트랜잭션이 대부분 그 대상
- 일반적으로는 성능적인 이슈가 발생하지 않으나, 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 Lock의 개수가 많아지게 되면 데드락 감지 스레드의 속도가 느려짐.
    - `innodb_deadlock_detect` 시스템 변수의 값을 `OFF`로 설정
    - 다만, 데드락이 발생하면 무한 대기
        - `innodb_lock_wait_timeout` 시스템 변수의 값을 수정하여 잠금을 획득하지 못한 트랜잭션을 일정 시간 후에 종료시키는 방법을 사용 가능
        - 기본값은 50초이지만, `innodb_deadlock_detect` 를 끈다면 낮추는걸 권장

## 자동화된 장애 복구

- `innodb_force_recovery` 시스템 변수를 설정하여 검사 과정을 선별적으로 진행가능

## InnoDB 버퍼 풀

- InnoDB 스토리지 엔진에서 **가장 핵심적인 부분**
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할

### 버퍼 풀의 크기 설정

- 기존에는 Semaphore를 사용하여 버퍼 풀의 Lock을 관리했는데, 현재는 하나의 큰 버퍼 풀을 여러 개로 쪼개면서 각 Semaphore에 대한 경쟁을 줄임

### 버퍼 풀의 구조

![6](https://github.com/user-attachments/assets/393a2e44-f3d2-4dc4-87d8-72c88b87d68d)

- LRU 리스트, Flush 리스트, Free 리스트 관리
- LRU(Least Recently Used) 리스트는 엄밀하게는 LRU + MRU(Most Recently Used) 리스트 결합
- 과정
    - 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
    - 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재, 적재된 페이지에 대한 포인터를 LRU 헤더에 추가
    - 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동
    - 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 Age 부여, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 Aging 하여 버퍼 풀에서 제거. 버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면 Age 초기화, MRU 헤더 부분으로 옮겨짐
    - 필요한 데이터가 자주 접근했다면 인덱스 키를 어댑티브 해시 인덱스에 추가
- 플러시 리스트는 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리

### 버퍼 풀과 Redo 로그

- 버퍼 풀의 기능은 데이터 캐시와 쓰기 버퍼링이 있음
- 하지만 크기를 올리는 것은 데이터 캐시 기능만 향상
    
    → 쓰기 버퍼링의 성능을 올리려면 Redo 로그 이해 필요
    
- `Clean Page` : 디스크에서 읽은 상태로 변경되지 않은 데이터
- `Dirty Page` : INSERT, UPDATE, DELETE 명령으로 변경된 데이터
- Redo 로그는 1개 이상의 고정 크기 파일을 연결하여 순환 고리처럼 사용하고, 결국 언젠가는 기존 로그가 덮어 씌어짐.
    - 재사용 가능한 공간과 그렇지 않은 공간을 표시해야 할 필요가 있음.
    - 재사용 불가능한 공간 - Active Redo Log.
    - 재사용 되어도 매번 기록될 때 마다 로그 포지션을 증가된 값을 갖는데, 이를 LSN (Log Sequence Number) 라고 함.
    - InnoDB는 주기적으로 체크포인트 이벤트를 발생시켜 Redo 로그와 Dirty Page를 디스크로 동기화 하는데, 이때 가장 최근 체크포인트 지점의 LSN이 활성 Redo 로그 공간의 시작점
    - 체크포인트가 발생하면 체크포인트 LSN 보다 작은 Redo 로그 엔트리와 관련된 Dirty Page는 모두 동기화가 된다고 할 수 있음.
- 결국 버퍼 풀의 크기가 커봤자, Redo 로그 파일의 크기가 작게되면 체크포인트 간의 간격 (즉, 활성 Redo 공간의 크기)는 결국 파일의 크기를 따라가게 되므로, 버퍼 성능이 그렇게 좋아지진 않음.

### Buffer Pool Flush

- 버퍼 풀에서 아직 디스크로 기록되지 않은 Dirty Page를 성능상 악영향 없이 디스크 동기화 필요
- 플러시 리스트 플러시
    - 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화
    - 얼마나 많은 Dirty Page를 한 번에 기록하냐가 성능에 영향
    - `클리너 스레드` : InnoDB에서 Dirty Page를 디스크로 동기화하는 스레드
    - 너무 Dirty Page의 수가 많아지면 Disk I/O Burst가 발생할 수 있음.
    - Adaptive Flush 기능을 사용하면, InnoDB는 Redo 로그의 증가 속도를 분석하여 적절한 수준의 Dirty Page가 버퍼 풀에 유지될 수 있도록 디스크 쓰기를 실행
- LRU 리스트 플러시
    - LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간 필요
    - LRU 리스트를 스캔하면서 Dirty Page는 동기화, Clean Page는 Free 리스트로 페이지를 옮김.

### 버퍼 풀 상태 백업 및 복구

### 버퍼 풀의 적재 내용 확인

## Double Write Buffer

- 일부만 기록되면 페이지 내용 복구 힘들 수 있음
- InnoDB는 실제 데이터 파일에 변경 내용을 기록하기 전, ‘A’ ~ ‘E’ 까지의 Dirty Page를 묶어서 한 번의 Disk Write로 DoubleWrite 버퍼에 기록함. → 이후에 쓰기 진행
- DoubleWrite 버퍼 공간에 기록된 내용은 실제 데이터 파일의 쓰기가 실패할 때만 사용

## Undo 로그

- Transaction Isolation 보장을 위해, DML (INSERT, UPDATE, DELETE) 로 변경되기 전 이전 버전의 데이터를 별도로 백업

### Undo 로그 레코드 모니터링

- Undo 로그의 데이터는 트랜잭션의 롤백 대비용/격리 수준 유지하면서 높은 동시성 제공이 목적
- MySQL 8.0 부터는 Undo 로그를 순차적으로 사용함으로써 디스크 공간 사용량 자체를 줄여버림.

### Undo 테이블스페이스 관리

- Undo 로그가 저장되는 공간
- 별도 파일로 관리
- Undo 테이블스페이스는 1 ~ 128개의 롤백 세그먼트를 가짐
- 각각의 롤백 세그먼트는 1개 이상의 Undo Slot을 가짐

## 체인지 버퍼

- 해당 테이블에 포함된 인덱스를 업데이트하는 작업 또한 필요
- InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있다면 바로 업데이트를 진행하지만, 그렇지 않다면 이를 바로 실행하지 않고 체인지 버퍼에 저장함.
- 결과를 전달하기 전 중복 여부를 체크해야 하는 Unique Index는 체인지 버퍼를 사용할 수 없음.
- 임시로 저장된 인덱스 레코드 조각은 이후 체인지 버퍼 머지 스레드라는 백그라운드 스레드에 의해 병합됨.

## Redo 로그 및 로그 버퍼

- HW/SW 문제로 인해 서버가 비정상적으로 종료되었을 때 데이터 파일에 기록되지 못한 데이터를 유지 시켜주는 안전장치
- 대부분의 DBMS는 데이터 변경 내용을 로그로 먼저 기록
    - 상당수의 DBMS는 쓰기보다 읽기에 최적화 되어 있으며, 그렇기에 쓰기 연산은 상당한 비효율 (ex. 랜덤 I/O) 를 보임 → 쓰기 비용이 낮은 자료구조를 갖는 Redo 로그를 활용함.
- Redo 로그를 버퍼링할 수 있는 로그 버퍼와 같은 자료구조도 있음.
- 시나리오를 설정해보자.
    - 커밋 되었지만 데이터 파일에 기록되지 않은 데이터
        - Redo 로그에 저장된 데이터를 붙여 넣기만 하면 됨.
    - 롤백 했지만 데이터 파일에 이미 기록된 데이터
        - 어떤 변경이 커밋/롤백 되었는지, 아니면 트랜잭션 실행 중인지 확인하는데 쓰임.
- Redo 로그는 트랜잭션이 커밋되면 바로 디스크에 기록되도록 시스템 변수를 설정하는 것이 권장됨.
    - innodb_flush_log_at_trx_commit 변수 활용

## Adaptive Hash Index

- 일반적으로 인덱스라고 하면 B-Tree 형식의 테이블 인덱스를 떠올림.
- Adaptive Hash Index는 InnoDB에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
- B-Tree는 빠른 편이지만, 결국 속도는 상대적이고 스레드의 수가 늘게 되면 엄청난 성능의 영향을 받음.
- Adaptive Hash Index를 사용하면, 자주 읽히는 데이터 페이지의 키 값을 활용해 해시 인덱스를 생성하고, 이에 접근하면 즉시 데이터 페이지로 찾아갈 수 있음.
- 인덱스 키 값은 B-Tree 인덱스의 고유번호 (Id) 와 B-Tree 인덱스의 실제 키 값 조합
- 버퍼 풀에 올려진 데이터 페이지에 대해서만 관리하고, 사라지면 같이 없앰.
- 다만 이런 기능임에도 불구하고 이전에는 Semaphore의 경쟁이 있었기에 정체가 발생했었지만, MySQL 8.0 부터는 파티션 기능을 추가함.
    - innodb_adaptive_hash_index_parts 시스템 변수 사용
- 하지만 실제로는 비활성화 하는 경우도 많은데…
    - 도움이 되지 않은 경우
        - 디스크 읽기가 많은 경우
        - 특정 패턴의 쿼리 (LIKE나 조인 같은) 가 많은 경우
        - 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우
    - 도움이 되는 경우
        - 디스크의 데이터가 InnoDB 버퍼 풀 크기와 큰 차이가 없는 경우
        - 동등 조건 검색 (IN이나 비교 같은) 이 많은 경우
        - 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우
- 결국 똑같은 메모리를 사용하기 때문에, 사용하지 않을 경우 제거하는 것이 맞음.
    - `SHOW ENGINE INNODB STATUS\G` 를 사용하면 다양한 로그를 확인할 수 있는데, 여기서 Hash를 사용한 검색과 사용하지 못한 검색의 비율을 비교할 수 있음.

# MyISAM 스토리지 아키텍쳐

# MySQL 로그 파일
