### **1. 인덱스란 무엇이며, 데이터베이스에서 왜 중요한가요?**

- **정의**  
  인덱스는 테이블 데이터의 특정 컬럼 값을 기반으로 정렬된 구조를 만들어 데이터를 빠르게 검색하기 위한 도구입니다.  
  책의 찾아보기(색인)와 유사하며, 데이터 주소를 저장하여 검색 속도를 향상시킵니다.

- **중요성**  
  1. **빠른 검색**: 대량 데이터에서도 효율적인 검색 가능.  
     - *예시*: 100만 건 테이블에서 전체를 스캔하는 대신 인덱스를 통해 몇 단계 만에 데이터를 찾음.
  2. **쿼리 최적화**: WHERE, ORDER BY, GROUP BY를 빠르게 처리.  
  3. **데이터 무결성 유지**: UNIQUE 인덱스나 PRIMARY KEY를 통해 데이터 중복 방지.

- **비교: 인덱스와 테이블 스캔**  
  | **구분**          | **인덱스**                           | **테이블 스캔**                      |
  |-------------------|-------------------------------------|-------------------------------------|
  | **속도**          | 빠르게 특정 데이터에 접근 가능         | 모든 데이터를 읽기 때문에 느림         |
  | **사용 사례**     | 대규모 데이터에서 조건 검색            | 소규모 데이터에서 간단한 조회에 적합  |

---

### **2. B-Tree 인덱스란 무엇이며, 주요 특성은 무엇인가요?**

- **정의**  
  B-Tree 인덱스는 **균형 잡힌 트리 구조**로, 데이터를 정렬하고 빠르게 탐색할 수 있도록 설계되었습니다.  
  루트 노드, 브랜치 노드, 리프 노드로 구성되며, 리프 노드는 데이터의 주소를 포함합니다.

- **특성**  
  1. **정렬 유지**: 인덱스 키는 항상 정렬된 상태를 유지.  
  2. **효율성**: 범위 검색 및 순서 조건 처리에 유리.  
  3. **균형**: 데이터 삽입/삭제 후에도 트리의 깊이가 일정.

- **비교: B-Tree와 Hash 인덱스**  
  | **구분**          | **B-Tree 인덱스**                  | **Hash 인덱스**                      |
  |-------------------|------------------------------------|-------------------------------------|
  | **정렬**          | 키 값 정렬 유지                    | 키 값이 정렬되지 않음                 |
  | **범위 검색**     | 가능                               | 불가능                               |
  | **사용 사례**     | 범위 조건 및 정렬 작업에 유리         | 정확히 일치하는 검색에 최적화         |

---

### **3. 인덱스 키 값 크기와 B-Tree 깊이는 성능에 어떤 영향을 미치나요?**

- **키 값 크기**  
  키 값이 작을수록 한 페이지에 더 많은 키를 저장할 수 있어 성능이 향상됩니다.  
  - *예시*: 키 크기가 16바이트인 경우, 한 노드에 585개의 자식 노드를 저장 가능. 키 크기가 32바이트라면 372개로 줄어듭니다.

- **트리 깊이**  
  깊이가 깊어질수록 탐색 단계가 늘어나 성능이 저하됩니다.  
  - *예시*: 깊이가 3인 트리는 약 2억 개 키를 저장 가능. 깊이가 4로 늘어나면 I/O 비용 증가.

---

### **4. 인덱스 선택도(기수성)는 무엇이며, 검색 성능에 미치는 영향은?**

- **정의**  
  인덱스 선택도는 인덱스에서 **고유한 값의 비율**을 의미합니다.  
  높은 선택도는 검색 성능을 높이고, 낮은 선택도는 성능 저하를 유발합니다.

- **비교: 높은 선택도 vs 낮은 선택도**  
  | **구분**         | **높은 선택도**                  | **낮은 선택도**                     |
  |------------------|----------------------------------|-------------------------------------|
  | **효율성**        | 검색 대상이 줄어들어 성능 우수       | 많은 데이터를 읽어야 하므로 성능 저하  |
  | **사용 사례**     | 주민등록번호, 계좌 번호 등 고유값     | 성별, 상태(Active/Inactive) 등 제한된 값 |

---

### **5. 다중 칼럼 인덱스는 무엇이며, 생성 시 고려해야 할 사항은?**

- **정의**  
  다중 칼럼 인덱스는 두 개 이상의 컬럼으로 구성된 인덱스입니다. WHERE 조건에서 여러 컬럼을 동시에 사용할 경우 효율적입니다.  
  - *예시*: `(last_name, first_name)`로 인덱스를 생성하면 두 컬럼을 정렬하여 검색 속도를 높입니다.

- **고려사항**  
  1. **컬럼 순서**: 선행 컬럼은 WHERE 조건에서 가장 빈번히 사용되는 컬럼으로 설정.  
  2. **쿼리 패턴**: 선행 컬럼 없이 후행 컬럼만 사용하는 경우 인덱스 활용이 어려움.  
  - *예시*: `WHERE first_name = 'John'`은 `(last_name, first_name)` 인덱스에서 비효율적.

- **비교: 단일 칼럼 vs 다중 칼럼 인덱스**  

  | **구분**          | **단일 칼럼 인덱스**              | **다중 칼럼 인덱스**              |
  |-------------------|----------------------------------|----------------------------------|
  | **구조**          | 하나의 컬럼으로 구성              | 두 개 이상의 컬럼 결합            |
  | **효율성**         | 특정 조건에서 더 효율적           | 복합 조건에서 더 효율적            |
  | **사용 사례**      | 단일 필드 검색                   | `(A AND B)`와 같은 복합 조건 검색 |

- **예시**  
  ```sql
  -- 단일 칼럼 인덱스
  CREATE INDEX idx_lastname ON employees (last_name);

  -- 다중 칼럼 인덱스
  CREATE INDEX idx_fullname ON employees (last_name, first_name);

  -- 다중 칼럼 인덱스 활용 쿼리
  SELECT * FROM employees WHERE last_name = 'Smith' AND first_name = 'John';

  -- 비효율적 사례: 다중 칼럼 인덱스에서 선행 컬럼 없이 후행 컬럼만 검색
  SELECT * FROM employees WHERE first_name = 'John';
  ```


---

### **6. 클러스터링 인덱스란 무엇이며, 넌클러스터링 인덱스와의 차이점은?**

- **정의**  
  클러스터링 인덱스는 테이블 데이터를 **프라이머리 키를 기준으로 정렬하여 저장**합니다.  
  테이블 자체가 인덱스 구조로 관리되며, 물리적 저장 순서가 프라이머리 키와 일치합니다.

- **넌클러스터링 인덱스와의 차이**  
  | **구분**          | **클러스터링 인덱스**                      | **넌클러스터링 인덱스**                 |
  |-------------------|------------------------------------------|---------------------------------------|
  | **정렬 기준**      | 프라이머리 키                            | 별도의 인덱스가 데이터 주소를 저장      |
  | **속도**          | 프라이머리 키 검색에 최적화               | 추가적인 데이터 접근 필요               |
  | **사용 제한**      | 테이블당 하나                            | 여러 개 생성 가능                      |

---

### **7. InnoDB에서 세컨더리 인덱스와 클러스터링 인덱스는 어떻게 연관되나요?**

- **클러스터링 인덱스**  
  클러스터링 인덱스는 테이블의 **프라이머리 키를 기준으로 데이터를 물리적으로 정렬**하여 저장합니다.  
  InnoDB 테이블에서 프라이머리 키는 클러스터링 인덱스로 설정되며, 데이터 레코드는 리프 노드에 직접 저장됩니다.

- **세컨더리 인덱스**  
  세컨더리 인덱스는 프라이머리 키가 아닌 다른 컬럼에 대해 생성된 인덱스입니다.  
  InnoDB에서 세컨더리 인덱스는 레코드의 물리적 주소를 저장하지 않고, **프라이머리 키 값을 참조**하여 데이터를 검색합니다.

- **연관성**  
  세컨더리 인덱스가 프라이머리 키를 참조하기 때문에, 다음과 같은 특성을 가집니다:
  1. **프라이머리 키 의존성**: 세컨더리 인덱스는 프라이머리 키가 변경되면 참조하는 값을 업데이트해야 합니다.
  2. **추가 검색 비용**: 세컨더리 인덱스를 통해 검색한 후 프라이머리 키를 사용해 다시 데이터를 검색해야 하므로 한 번의 추가적인 검색 작업이 필요합니다.
  3. **인덱스 크기 증가**: 모든 세컨더리 인덱스가 프라이머리 키 값을 포함하므로 프라이머리 키가 길면 세컨더리 인덱스 크기도 커집니다.

- **비교: 세컨더리 인덱스 vs 클러스터링 인덱스**  
  | **구분**          | **클러스터링 인덱스**                            | **세컨더리 인덱스**                        |
  |-------------------|-----------------------------------------------|-----------------------------------------|
  | **데이터 저장**    | 테이블 레코드가 리프 노드에 저장                 | 인덱스에 프라이머리 키를 저장 후 데이터 참조 |
  | **속도**          | 프라이머리 키 검색에 최적화                      | 추가 검색 단계 필요                        |
  | **크기**          | 테이블 데이터와 동일                            | 프라이머리 키 크기에 따라 크기 증가          |
  | **사용 제한**      | 테이블당 하나                                    | 여러 개 생성 가능                          |

- **예시**  
  ```sql
  CREATE TABLE employees (
      emp_no INT NOT NULL,
      first_name VARCHAR(20) NOT NULL,
      PRIMARY KEY (emp_no),
      INDEX ix_firstname (first_name)
  );

  -- 클러스터링 인덱스: PRIMARY KEY (emp_no)
  -- 세컨더리 인덱스: INDEX ix_firstname (first_name)
  SELECT * FROM employees WHERE first_name = 'John';
  ```

  - InnoDB는 **ix_firstname** 세컨더리 인덱스를 검색하여 프라이머리 키(emp_no)를 가져오고, 이를 이용해 클러스터링 인덱스를 검색하여 최종 데이터를 반환합니다.  
  MyISAM과 달리 세컨더리 인덱스가 데이터 주소를 직접 저장하지 않기 때문에 추가적인 검색 비용이 발생합니다.


---

### **8. R-Tree 인덱스는 무엇이며, 어떤 용도로 사용되나요?**

- **정의**  
  R-Tree는 **2차원 공간 데이터를 인덱싱**하기 위해 사용되며, 지도나 GPS 서비스에 주로 활용됩니다.  
  각 데이터는 최소 경계 사각형(MBR)으로 관리됩니다.

- **용도**  
  - *예시*: 특정 위치 범위의 데이터를 효율적으로 검색(GPS 좌표, 도형).

---

### **9. 함수 기반 인덱스와 가상 칼럼을 이용한 인덱스의 차이점은 무엇인가요?**

- **함수 기반 인덱스**  
  특정 함수나 표현식을 기반으로 인덱스를 생성. 테이블 구조 변경 없이 추가 가능.  
  - *예시*: `CONCAT(first_name, ' ', last_name)` 기반 인덱스.

- **가상 칼럼 기반 인덱스**  
  가상 칼럼을 생성 후 해당 칼럼에 인덱스를 적용. 테이블 구조 변경 필요.  
  - *예시*: `ALTER TABLE user ADD full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL;`

- **비교**  
  | **구분**          | **함수 기반 인덱스**                | **가상 칼럼 기반 인덱스**            |
  |-------------------|------------------------------------|------------------------------------|
  | **테이블 구조**    | 변경 필요 없음                      | 테이블 구조 변경 필요               |
  | **사용 편의성**    | 단순 조건에 적합                    | 계산된 결과를 다른 작업에도 활용 가능 |

---

### **10. 멀티 밸류 인덱스란 무엇이며, 일반 인덱스와 차이점은?**

- **정의**  
  멀티 밸류 인덱스는 **하나의 레코드에 여러 인덱스 값을 허용**하는 구조입니다.  
  주로 JSON 배열 데이터를 처리할 때 사용됩니다.

- **일반 인덱스와의 차이**  
  | **구분**          | **일반 인덱스**                  | **멀티 밸류 인덱스**                |
  |-------------------|---------------------------------|------------------------------------|
  | **키 값 수**       | 한 레코드당 하나의 키             | 한 레코드에 여러 키 가능             |
  | **사용 목적**      | 일반 데이터 검색                  | JSON 배열 데이터 검색               |

---

