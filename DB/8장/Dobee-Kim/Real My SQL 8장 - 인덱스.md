# Real My SQL 8장 - 인덱스

Favorite: No
Reviewed: No
Status: Study Review
날짜: 2024년 12월 30일
생성 일시: 2024년 12월 30일 오후 4:49

- 목차

## 8.1 디스크 읽기 방식

- 데이터 저장 매체(기계식)는 컴퓨터에서 가장 느린 부분 → 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건

### 하드 디스크 드라이브와 솔리드 스테이트 드라이브 (HDD, SSD)

- SSD(전자식)가 HDD(기계식)
    - 기존 HDD 인터페이스(SATA나 SAS)를 지원함
    - HDD에서 데이터 저장용 플래터를 제거하고, 플래시 메모리를 장착.
    - D-RAM보다는 느리지만 HDD보다는 빠름
- SSD의 장점 : 기존 HDD보다 랜덤 I/O가 훨씬 빠름
    - 데이터베이스 서버에서는 순차 I/O 비중 < 랜덤 I/O 비중
    
    ⇒ DBMS용 스토리지에 최적
    

### 랜덤 I/O와 순차 I/O

![image.png](image.png)

- 디스크에 기록해야할 위치를 찾기 위해 순차 I/O는 디스크 헤드를 1번만 움직이지만, 랜덤 I/O는 페이지 개수만큼 움직임
    
    ⇒ 디스크에 데이터를 쓰고 읽는 데 걸리는 시간 = 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정
    
- 쿼리 튜닝 : 랜덤 I/O 자체를 줄여주는 것이 목적 → 꼭 필요한 데이터만 읽도록 쿼리를 개선

## 8.2 인덱스란?

- 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어둠
- DBMS 인덱스는 칼럼의 값을 주어진 순서로 미리 정렬해서 보관함
    - 인덱스는 sortedList와 같음. 데이터파일은 ArrayList와 같이 별도 정렬 없이 보관
    - sortedList는 데이터 저장때마다 항상 값을 정렬해야함 → 저장과정이 복잡하고 느림
    
    ⇒ DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 대신 데이터 읽기 속도를 높이는 기능
    

### 분류

- 인덱스 역할별 : Primary Key, Secondary Key
- 데이터 저장방식별 : B-Tree, R-Tree(B-tree 응용), Hash 인덱스 알고리즘
- 데이터 중복 허용 여부 : Unique Index, Non-Unique index
    
    ⇒ 옵티마이저에게 중요 (유니크 인덱스에 동등조건(Equal, =)으로 검색한다는 것은 항상 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 알려주는 것)
    

## 8.3 B-Tree 인덱스

- B+-Tree 또는 B*-Tree가 DBMS에서 주로 사용됨
- Balanced Tree
- 원래 값을 변형시키지 않고, 인덱스 구조체 내에서는 항상 정렬된 상티 유지

### 구조 및 특성

- 인덱스와 실제 데이터가 저장된 데이터는 따로 관리
- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소값을 가짐

![image.png](image%201.png)

- INSERT된 순서로 저장되는 것 X Why? 레코드 삭제되어 빈 공간이 생기면 가능한 한 삭제된 공간을 재활용하도록 DBMS가 설계됨

![image.png](image%202.png)

![image.png](image%203.png)

### **MyISAM 스토리지 엔진의 동작 방식**

- **레코드 주소**: MyISAM에서는 테이블이 생성되고, 데이터가 삽입(INSERT)될 때마다 데이터가 저장된 파일의 위치(Offset)를 기록합니다.
- **인덱스 구조**: MyISAM의 인덱스는 데이터가 저장된 파일의 위치를 직접 가리킵니다.
    - 즉, 인덱스는 데이터가 저장된 **물리적 위치**를 기억하고 있어서 빠르게 해당 데이터를 찾을 수 있습니다.
- **결과**: MyISAM은 데이터를 읽는 속도가 빠르지만, 데이터를 자주 수정하거나 삭제하면 파일 조각화가 발생할 수 있습니다.

### **InnoDB 스토리지 엔진의 동작 방식**

- **클러스터링 인덱스**: InnoDB는 데이터를 저장할 때 기본적으로 **프라이머리 키(Primary Key)**를 기준으로 정렬합니다.
    - 프라이머리 키 값이 인덱스 역할을 하며, 데이터 자체도 이 인덱스에 함께 저장됩니다.
- **ROWID**: 만약 프라이머리 키가 없는 경우, InnoDB는 내부적으로 레코드마다 고유한 ROWID를 생성하여 이를 기반으로 데이터를 관리합니다.
- **인덱스 구조**:
    - InnoDB의 인덱스는 데이터를 가리키는 것이 아니라 **프라이머리 키**를 가리킵니다.
    - 그 후, 프라이머리 키를 통해 데이터를 찾습니다.
- **결과**: InnoDB는 데이터를 읽는 데 약간의 추가 작업이 필요하지만, 데이터 수정이나 삭제 시 성능이 더 안정적입니다.

### **MyISAM과 InnoDB의 비교**

- **MyISAM의 장점**:
    - 데이터를 읽는 속도가 빠름(인덱스가 물리적 위치를 바로 가리키기 때문).
    - 구조가 간단하여 데이터 읽기 작업에 적합.
- **InnoDB의 장점**:
    - 데이터 수정, 삭제 시 성능 저하가 덜함(프라이머리 키 기반 인덱스 사용).
    - 트랜잭션과 외래 키(Foreign Key)를 지원하여 데이터 무결성이 강화됨.
- **단점 비교**:
    - MyISAM은 데이터를 삭제하거나 수정하면 조각화 문제가 발생할 수 있음.
    - InnoDB는 데이터를 읽을 때 MyISAM보다 조금 느릴 수 있음.

### B-Tree 인덱스 키 추가 및 삭제

- 인덱스키 추가
    - B-Tree는 쓰기작업 비용이 많이 듬
    - 저장될 키 값을 이용해 B-Tree상 적절한 위치 검색 → 저장될 위치가 결정되면 레코드 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장
    - 리프노드가 꽉 차서 더 저장할 수 없을 땐, 리프 노드가 분리돼야 함 → 상위 브랜치 노드까지 처리의 범위가 넓어짐
    - MyISAM, MEMORY 스토리 엔진에서는 즉시 새로운 키값을 B-Tree 인덱스에 변경
    - InnoDB 스토리지 엔진은 필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리 (프라이머리 키나, 유니크 인덱스는 중복 체크가 필요하기 떄문에 즉시 B-Tree에 추가 삭제)
- 인덱스 키 삭제
    - 해당 키 값이 저장된 B-Tree의 리프노드를 찾아서 그냥 삭제 마크 (디스크 I/O가 필요)
- 인덱스 키 변경
    - 인덱스의 키 값은 그 값에 따라 저장될 리프노드의 위치가 결정됨
    
    <aside>
    💡
    
    왜?
    
    </aside>
    
    - 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리됨
- 인덱스 키 검색
    - 트리 탐색 : 루트 노드부터 시작해 최종 리프노드까지 이동하면서 비교 작업 수행
    - B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에사용이 가능
    - 인덱스 키 값에 변형이 가해진 후 비교되는 경우에는 빠른 검색 기능을 사용할 수 없음 → 함수나 연산을 수행한 결과로 정렬하거나 검색하는 작업은 B-Tree의 장점을 이용할 수 없음
    - InnoDB 스토리지 엔진에서 더 중요 → 레코드 잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현 → 인덱스가 없으면 불필요하게 많은 레코드를 잠금

### B-Tree 인덱스 사용에 영향을 미치는 요소

1. **InnoDB의 기본 저장 단위**:
    - 데이터를 저장하는 기본 단위는 **페이지(Page)** 또는 **블록(Block)**으로, 디스크의 최소 읽기 및 쓰기 작업 단위임.
    - 기본적으로 페이지 크기는 **16KB**.
2. **인덱스 구조**:
    - InnoDB는 **B-Tree 구조**를 사용하며, 각 노드는 자식 노드의 주소를 포함한 데이터를 저장.
    - 자식 노드 주소는 평균적으로 **12바이트** 크기로 가정.
3. **인덱스 페이지 구성**:
    - 한 페이지(16KB)에는 인덱스 키 값과 자식 노드의 주소 정보가 저장됨.
    - 자식 노드 주소가 평균적으로 **12바이트** 크기를 가지므로, 페이지 하나에 약 **585개의 키**를 저장할 수 있음.
    - 만약 자식 노드의 키 값 크기가 커진다면, 한 페이지에 저장할 수 있는 키의 수는 줄어듦.
    - 예를 들어, 키 값 크기를 **32바이트**로 가정할 경우, 한 페이지에 **372개**의 키를 저장할 수 있음.
4. **B-Tree 효율성**:
    - 인덱스 키 크기와 자식 노드 주소 크기에 따라 페이지 내 저장 가능한 키의 개수가 달라짐.
    - 인덱스 키 크기가 증가하면 B-Tree의 높이가 증가하여 성능 저하를 초래할 수 있음.

### **B-Tree 깊이**

1. **B-Tree 인덱스의 깊이(Depth)의 중요성**:
    - 인덱스 키 값 크기가 커지면 B-Tree의 깊이가 깊어질 가능성이 높아짐.
    - 깊이가 깊어지면 디스크 읽기 횟수가 증가하여 성능 저하를 초래.
2. **키 값 크기와 B-Tree 깊이**:
    - 예를 들어, **키 값 크기 16바이트**일 경우:
        - 최대 **29억 개(585 × 585 × 585)** 데이터를 담을 수 있는 3단계 깊이의 B-Tree 구성 가능.
    - 키 값 크기가 커질 경우, 한 페이지에 담을 수 있는 키 값 수가 줄어들어 B-Tree의 깊이가 깊어질 수 있음.
3. **인덱스 키 값 크기의 제약**:
    - InnoDB는 키 캐시 영역 크기에 제약이 있어, 키 값 크기가 커지면 캐싱 가능한 레코드 수가 감소.
    - 이는 메모리 효율 저하와 함께 성능 저하를 초래함.

### **선택도(가수성, Selectivity)**

1. **선택도의 정의**:
    - 선택도(Selectivity) 또는 가수성(Cardinality)은 인덱스 키 값이 검색 대상에서 얼마나 유니크한지를 나타내는 지표.
    - 선택도가 높을수록 인덱스의 효율성이 향상됨.
2. **선택도 계산**:
    - 인덱스 키 값이 100개라면, 유니크한 값이 10개인 경우 선택도는 **10%**.
    - 선택도가 높을수록 검색 대상이 줄어들어 빠른 검색 가능.
3. **실제 활용**:
    - 인덱스의 선택도는 검색 성능 최적화의 중요한 요소로 작용함.

### **인덱스 설계의 적합성 예제**

1. **테이블 구조**:
    - `tb_test` 테이블에는 `country`와 `city`라는 두 칼럼이 포함되어 있으며, 전체 레코드 수는 **1만 건**임.
    - `country` 칼럼에 인덱스를 생성한 상태에서 두 가지 케이스를 비교.
2. **케이스 비교**:
    - **케이스 A**:
        - `country` 칼럼의 유니크한 값 개수는 **10개**.
        - 쿼리 실행 시 **1건만 읽음**으로 성능이 좋음.
    - **케이스 B**:
        - `country` 칼럼의 유니크한 값 개수는 **1,000개**.
        - 쿼리 실행 시 조건을 만족하는 레코드가 많아 **9,999건을 추가로 읽음**.
3. **결론**:
    - A 케이스에서는 `country`에 생성된 인덱스가 적합하지만, B 케이스에서는 인덱스 효율이 떨어질 수 있음.
    - 적합한 인덱스를 설계하려면 **데이터 분포**와 **쿼리 조건**을 고려해야 함.

---

### **다른 테이블 예제**

1. **`tb_city` 테이블 구조**:
    - 국가별 도시 정보를 저장하며, `country`와 `city` 칼럼을 가짐.
    - `country` 칼럼에 인덱스가 생성된 상태.
2. **쿼리 최적화**:
    - `SELECT` 쿼리를 실행할 때, `country`와 `city`의 분포를 고려하여 효율적인 인덱스를 설계해야 함.

---

### **참고**

- **인덱스 생성 시 고려사항**:
    - 데이터의 **선택도(Selectivity)**와 **쿼리 패턴**에 따라 인덱스 효율이 달라짐.
    - 모든 조건을 만족하는 인덱스는 현실적으로 어려울 수 있으므로, **우선순위**에 따라 설계 필요.
- **인덱스를 사용할 때 효율적인 경우**: 읽어야 할 데이터가 전체의 20~25% 이하일 때.
- **대표적 접근 방식**: **인덱스 레인지 스캔**을 통해 범위 조건에 해당하는 데이터만 읽는 방식.
- **쿼리 작성 팁**: 범위 조건(`BETWEEN`)을 활용하면 인덱스를 효과적으로 사용할 수 있음.

### **인덱스 레인지 스캔(Index Range Scan)**

1. **개념**:
    - **인덱스의 범위**가 결정된 경우 사용하는 검색 방식.
    - 루트 노드에서부터 브랜치 노드를 거쳐 **리프 노드**로 이동하며, 필요한 데이터만 순차적으로 읽음.
2. **작동 방식**:
    - 루트 노드에서 검색 조건에 해당하는 범위를 확인하고, 조건에 맞는 **브랜치 노드**로 이동.
    - 브랜치 노드에서 **리프 노드**의 시작 위치를 찾아 이동.
    - 리프 노드의 데이터를 순차적으로 읽으며, 범위 끝에 도달하면 스캔이 종료.
3. **리프 노드 간 이동**:
    - 리프 노드에서 데이터가 끝나면, **리프 노드 간의 링크**를 통해 다음 리프 노드로 이동하여 스캔을 계속 진행.
4. **효율성**:
    - 필요한 범위의 데이터만 읽기 때문에 효율적.
    - 다만, 리프 노드를 스캔하면서 **실제 데이터 파일**을 읽어야 할 경우, 읽기 작업이 추가되어 성능이 영향을 받을 수 있음.

### **인덱스를 통한 데이터 읽기 과정**

1. **3단계 과정**:
    - **1단계: 인덱스 탐색(Index Seek)**
        - 조건에 맞는 값이 저장된 위치를 찾는 과정.
    - **2단계: 인덱스 스캔(Index Scan)**
        - 탐색된 위치부터 필요한 범위의 데이터를 순차적으로 읽는 과정.
    - **3단계: 레코드 읽기**
        - 인덱스를 통해 찾은 레코드 주소로 저장된 페이지를 가져와 최종 데이터를 읽음.
2. **커버링 인덱스(Covering Index)**:
    - 필요한 데이터가 인덱스만으로도 충분히 처리 가능한 경우.
    - 디스크 I/O 작업 없이 데이터를 처리할 수 있어 성능이 매우 빠름.

---

### **MySQL의 핸들러(Handler) 상태 값**

1. **SHOW STATUS LIKE 'Handler_%';**
    - MySQL 서버에서 인덱스 탐색 및 읽기 작업이 얼마나 수행되었는지 확인 가능.
2. **주요 핸들러 변수**:
    - **Handler_read_key**:
        - 1단계(인덱스 탐색)가 실행된 횟수.
    - **Handler_read_next**:
        - 2단계에서 순차적으로 읽은 레코드 수.
    - **Handler_read_prev**:
        - 2단계에서 역순으로 읽은 레코드 수.
    - **Handler_read_first, Handler_read_last**:
        - 인덱스의 첫 번째 또는 마지막 레코드를 읽은 횟수.

---

### **핸들러 값 분석**

- **Handler_read_key**:인덱스를 통해 특정 키를 탐색한 작업 횟수.
- **Handler_read_next**:정순으로 레코드를 읽은 횟수. 범위 검색에서 주로 발생.
- **Handler_read_prev**:역순으로 레코드를 읽은 횟수.
- **Handler_read_first/last**:첫 번째 또는 마지막 레코드 접근 시 증가.→ MIN(), MAX() 함수 사용 시 주로 발생.

---

### **결론**

- 핸들러 값을 통해 인덱스 작업의 효율성을 확인할 수 있음.
- **커버링 인덱스**는 테이블 데이터를 읽지 않고 인덱스만으로 처리하므로 가장 효율적인 방식.

### **인덱스 풀 스캔(Index Full Scan)**

1. **개념**:
    - **인덱스 레인지 스캔**과 달리, **인덱스의 처음부터 끝까지 모든 데이터를 읽는 방식**.
    - 특정 칼럼(조건에 사용된 칼럼)이 정렬된 상태일 때, **인덱스만**을 사용하여 쿼리를 처리할 경우 사용.
2. **사용 사례**:
    - 쿼리가 인덱스의 특정 칼럼만으로 처리가 가능할 때.
    - 테이블 전체를 읽는 것보다 효율적인 경우.
3. **작동 방식**:
    - 리프 노드의 제일 앞이나 뒤에서 시작.
    - 인덱스의 리프 노드들을 연결하는 **링크드 리스트(Linked List)**를 따라 **순차적으로 끝까지 스캔**.
    - 인덱스만으로 쿼리를 처리하며, **테이블 데이터를 읽지 않음**.
4. **효율성**:
    - **테이블 풀 스캔**보다는 효율적이나, 필요하지 않은 데이터도 읽게 되므로 성능은 **레인지 스캔**보다 낮음.
    - 인덱스 크기가 테이블 크기보다 작기 때문에 전체 테이블을 읽는 작업보다 비용이 적음.

### **결론**

- **인덱스 풀 스캔**은 특정 조건에 따라 효율적인 방식이 될 수 있으나, **레인지 스캔**보다는 성능이 낮음.
- 테이블 데이터를 읽지 않아도 되는 쿼리라면 사용 가능하며, **테이블 풀 스캔**을 대체할 수 있는 방법으로 활용됨.

### **루스 인덱스 스캔(Loose Index Scan)**

1. **개념**:
    - 루스(Loose) 인덱스 스캔은 **느슨하게** 또는 **뭉뚱그려서** 인덱스를 읽는 방식.
    - 일반적인 인덱스 스캔 방식과는 달리, 필요한 데이터만 골라내어 효율성을 높이는 방식.
    - **루스 인덱스 스캔**은 인덱스 레인지 스캔과 비슷하지만, **중간에 필요하지 않은 인덱스 키 값을 건너뛰는(Skip)** 방식으로 작동.
    - 일반적으로 `GROUP BY`, `MIN()`, `MAX()` 같은 **집합 함수**의 최적화에 사용.
2. **사용 목적**:
    - MySQL 8.0부터 다른 상용 DBMS에서 지원하는 **최적화된 인덱스 스캔** 기능을 도입.
    - **일부 조건만 만족하는 레코드**를 읽는 데 효과적.
3. **DBMS의 용어 구분**:
    - 루스 인덱스 스캔은 일반적인 **타이트(Tight) 인덱스 스캔**과 대비되는 개념.
        - 타이트 스캔: 모든 조건을 완전히 만족하는 데이터를 읽음.
        - 루스 스캔: 일부 조건만 만족하는 데이터를 골라냄.
4. **예제 쿼리**:
    
    ```sql
    sql
    코드 복사
    SELECT dept_no, MIN(emp_no)
    FROM dept_emp
    WHERE dept_no BETWEEN 'd002' AND 'd004'
    GROUP BY dept_no;
    
    ```
    
    - `dept_no`와 `emp_no`로 생성된 인덱스를 사용.
    - `dept_no`를 기준으로 그룹화하고, 각 그룹에서 최소 `emp_no` 값을 가져옴.
    - **루스 인덱스 스캔**은 조건에 맞는 범위 내에서 **불필요한 레코드를 건너뛰고 필요한 데이터만 읽음**.
5. **효율성**:
    - 조건을 만족하지 않는 데이터를 건너뛰기 때문에 **디스크 I/O 작업이 줄어듦**.
    - **범위 내 특정 조건**만 읽기 때문에 쿼리 성능이 향상됨.

---

### **8.3.4.4 인덱스 스킵 스캔 (Index Skip Scan)**

1. **개념**:
    - **인덱스의 정렬된 구조를 활용**하여, **중복된 값 그룹을 건너뛰며 검색**하는 방식.
    - 인덱스에서 특정 칼럼이 선행 칼럼으로 설정되어 있더라도, 후속 칼럼을 기준으로 검색할 수 있음.
2. **예제 쿼리**:
    
    ```sql
    sql
    코드 복사
    ALTER TABLE employees
    ADD INDEX ix_gender_birthdate (gender, birth_date);
    
    -- 인덱스를 사용할 수 없는 경우:
    SELECT * FROM employees WHERE birth_date > '1965-02-01';
    
    -- 인덱스를 사용할 수 있는 경우:
    SELECT * FROM employees WHERE gender = 'M' AND birth_date > '1965-02-01';
    
    ```
    
    - **인덱스 정의**: `gender`가 선행, `birth_date`가 후속 칼럼.
    - 조건에 **선행 칼럼(gender)**이 포함되지 않으면 인덱스를 사용할 수 없음.
    - **선행 칼럼이 조건에 포함된 경우**, **스킵 스캔**을 통해 필요한 데이터만 검색.
3. **효율성**:
    - 선행 칼럼의 값 그룹을 건너뛰며 검색하기 때문에 효율적.
    - 복합 인덱스에서 특정 조건이 없을 때도 사용할 수 있는 방법.

### **인덱스 스킵 스캔(Index Skip Scan)**

1. **개념**:
    - **복합 인덱스**에서 선행 칼럼 값을 고정하지 않고 후행 칼럼을 기준으로 데이터 검색을 수행하는 방식.
    - 인덱스의 정렬된 구조를 활용하여 **선행 칼럼 값 그룹을 건너뛰며** 데이터를 검색.
2. **예제**:
    
    ```sql
    sql
    코드 복사
    ALTER TABLE employees
    ADD INDEX ix_gender_birthdate (gender, birth_date);
    
    -- 인덱스를 사용하지 못하는 경우:
    SELECT * FROM employees WHERE birth_date > '1965-02-01';
    
    -- 인덱스를 사용하는 경우:
    SELECT * FROM employees WHERE gender = 'M' AND birth_date > '1965-02-01';
    
    ```
    
    - 선행 칼럼 `gender`가 조건에 포함되지 않으면 인덱스를 사용할 수 없음.
    - 조건이 포함된 경우, **스킵 스캔**을 통해 후행 칼럼(`birth_date`) 기준으로 데이터를 검색.
3. **MySQL 8.0에서의 변화**:
    - MySQL 8.0 이전에는 스킵 스캔 최적화를 수행하지 못했음.
    - MySQL 8.0 이후, 옵티마이저에서 **스킵 스캔 최적화**를 지원하여 효율적인 데이터 검색 가능.
4. **EXPLAIN 실행 계획 비교**:
    - **스킵 스캔이 꺼진 경우**:
        - 쿼리가 인덱스를 사용하지 않고 테이블 풀 스캔을 수행.
    - **스킵 스캔이 활성화된 경우**:
        - `EXTRA` 항목에 `Using index for skip scan`이 표시되며, 인덱스를 효율적으로 사용.
5. **효율성**:
    - 선행 칼럼 값의 **유니크 값 개수**가 적을수록 효과적.
    - 유니크 값이 많으면 시작 지점을 찾는 작업이 오히려 비효율적일 수 있음.

---

### **그림 설명 (8.12)**:

- **인덱스 스킵 스캔의 처리 과정**:
    - 선행 칼럼 `gender`의 각 값(`M`, `F`)에 대해 후행 칼럼(`birth_date`)의 범위를 검색.
    - 조건을 만족하는 레코드만 반환.

---

### **제약 사항 및 단점**

1. **유니크 값 조건**:
    - 선행 칼럼 값의 유니크 값이 많으면 스킵 스캔의 성능 저하 가능.
2. **쿼리 조건 제한**:
    - WHERE 조건에서 선행 칼럼 값을 특정하지 않으면 비효율적.

### **8.3.5 다중 칼럼(Multi-column) 인덱스**

1. **개념**:
    - 다중 칼럼 인덱스는 두 개 이상의 칼럼을 포함하는 인덱스.
    - 첫 번째 칼럼을 기준으로 정렬되고, 그다음 두 번째 칼럼이 정렬되며, 이후 칼럼이 계층적으로 정렬.
2. **장점**:
    - 특정 조건의 결합 검색에서 효율적.
    - 한 번의 인덱스를 사용해 여러 조건을 처리 가능.
3. **주의점**:
    - 쿼리가 첫 번째 칼럼부터 시작하지 않으면 인덱스를 사용할 수 없음.

---

### **8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향**

1. **정렬 방향**:
    - MySQL 8.0 이전에는 각 칼럼에 대해 ASC(오름차순) 또는 DESC(내림차순) 혼합 정렬이 불가능했으나, 8.0 이후부터 지원.
2. **EXPLAIN 계획 비교**:
    - 쿼리 실행 계획에서 `Using index` 또는 `Using index for skip scan`이 표시되면 인덱스를 효율적으로 사용하는 것.

---

### **내림차순 인덱스**

1. **내림차순 인덱스의 특징**:
    - 내림차순 정렬이 필요한 경우 별도의 인덱스를 생성하여 효율성을 높임.
    - 예: `CREATE INDEX ix_name_score ON employees (team_name ASC, user_score DESC);`
2. **내림차순 테스트**:
    - 테이블 데이터를 내림차순으로 스캔하여 효율성을 비교.

---

### **Forward/Backward Index Scan**

1. **정방향(Forward)**:
    - 작은 값부터 큰 값으로 데이터를 읽음.
2. **역방향(Backward)**:
    - 큰 값부터 작은 값으로 데이터를 읽음.

---

### **테스트 결과**

- 정방향과 역방향 스캔은 각자의 장점이 있으며, 상황에 따라 사용.
- LIMIT 조건을 사용하면 정렬 방향에 따른 성능 차이가 크게 나타날 수 있음.

---

### **결론**

- MySQL 8.0부터 다중 칼럼, 혼합 정렬, 내림차순 인덱스 등 유연한 옵션을 지원하여 쿼리 최적화 가능.
- 서비스 요구사항에 따라 적합한 인덱스를 선택해야 함.

---

### **B-Tree 인덱스의 가용성과 효율성**

1. **효율성 판단 기준**:
    - 인덱스는 쿼리의 조건에 따라 효율적으로 사용할 수 있는 경우와 그렇지 않은 경우가 있음.
    - WHERE 조건에 따라 인덱스를 완전히 활용하지 못하는 경우도 존재.

---

### **비교 조건의 종류와 효율성**

1. **다중 칼럼 인덱스에서 각 칼럼의 순서와 사용된 조건의 중요성**:
    - 쿼리 조건의 범위(`>=`, `<`)가 포함되면 인덱스가 일부만 활용될 가능성이 있음.
    - 각 칼럼의 비교 조건에 따라 인덱스 활용도가 달라짐.
2. **사례 비교**:
    - **케이스 A**: `INDEX(dept_no, emp_no)`를 사용할 때, `dept_no`와 `emp_no`의 조건을 함께 만족시키는 경우.
    - **케이스 B**: `INDEX(emp_no, dept_no)`를 사용할 때, 조건이 일부만 인덱스에 영향을 미치는 경우.

---

### **인덱스의 가용성**

- B-Tree 인덱스는 **왼쪽부터 정렬 기준(Left-most)**을 따르며, 첫 번째 칼럼이 쿼리에 포함되지 않으면 인덱스를 사용할 수 없음.
- 예제:
    
    ```sql
    sql
    코드 복사
    SELECT * FROM employees WHERE first_name LIKE '%mer';
    
    ```
    
    - 위 쿼리는 인덱스의 **왼쪽 정렬 특성**을 활용하지 못하므로 인덱스 비효율적.

---

### **가용성과 효율성 판단**

1. **사용할 수 없는 조건**:
    - `NOT`, `<>`, `NOT IN`, `LIKE '%x%'` 등.
    - 데이터 변환이 필요한 경우(예: 함수 적용).
2. **사용할 수 있는 조건**:
    - `=` 또는 `IN` 등의 동등 조건.
    - 일부 범위 조건(예: `>=`, `<`).

---

### **다중 칼럼 인덱스 활용 조건**

- 칼럼 1부터 순차적으로 조건이 적용되어야 인덱스 사용 가능.
- 예제:
    
    ```sql
    sql
    코드 복사
    INDEX ix_test(column1, column2, column3)
    
    -- 사용할 수 없는 경우:
    WHERE column1 <> 2;
    
    -- 사용할 수 있는 경우:
    WHERE column1 = 1 AND column2 > 10;
    
    ```
    

### 다중 인덱스

- **다중 칼럼 인덱스**는 여러 개의 칼럼을 결합하여 인덱스를 생성한 것으로, 각각의 칼럼이 특정 순서대로 정렬된 상태로 저장됩니다.
- 다중 인덱스를 사용할 때는 칼럼 순서가 중요하며, 인덱스의 첫 번째 칼럼이 검색 조건에 포함되지 않으면 인덱스를 효과적으로 활용할 수 없습니다.
- 예를 들어 `INDEX(column1, column2, column3)`가 있을 때, `column1` 없이 `column2`나 `column3`만 검색 조건에 사용되면 인덱스의 효율성이 떨어집니다.

### R-Tree 인덱스

- R-Tree 인덱스는 공간 데이터를 저장하고 검색하기 위한 데이터 구조로, MySQL에서는 공간 확장(Spatial Extension) 기능으로 지원됩니다.
- 주로 **위치 기반 서비스**, **GIS 데이터** 또는 **GPS 좌표 데이터** 등을 처리할 때 사용됩니다.
- 데이터가 2차원으로 표현되며, 도형(예: 점, 선, 다각형)의 최소 경계 상자(MBR: Minimum Bounding Rectangle)를 기반으로 트리 구조를 형성합니다.
- **MBR**은 도형이 포함된 최소한의 직사각형으로, 공간 데이터의 검색 효율성을 높이는 데 도움을 줍니다.

### **인덱스 탐색과 스캔**

- **Index Seek**: 특정 값을 찾기 위해 인덱스를 탐색.
- **Index Scan**: 필요한 데이터가 포함된 범위를 모두 읽는 방식.
- **Index Full Scan**: 인덱스의 처음부터 끝까지 순차적으로 읽음.

---

### **루스(Lose) 인덱스 스캔**

- MySQL 8.0에서 `GROUP BY`나 집합 함수(`MAX`, `MIN`) 최적화를 위해 활용.
- 불필요한 레코드를 스킵하며 필요한 조건만 처리.
- 장점: 효율적인 집합 연산.

---

### **내림차순 인덱스**

- MySQL 8.0 이전에는 오름차순 인덱스만 지원.
- 내림차순 인덱스를 생성하여 쿼리 효율성 극대화 가능.

---

### **다중 칼럼 인덱스**

- 여러 개의 칼럼을 포함한 인덱스로, 칼럼의 순서가 중요.
- 조건이 첫 번째 칼럼에 맞지 않으면 인덱스 활용 불가.

---

### **B-Tree 인덱스**

- 기본 인덱스 구조로 WHERE, ORDER BY, GROUP BY 조건에 적합.
- **제약 사항**: `NOT IN`, `NOT BETWEEN` 등 비교 연산에서는 활용 불가.

---

### **R-Tree 인덱스**

- 공간 데이터를 저장하고 검색하기 위한 인덱스.
- MySQL에서 `GEOMETRY` 데이터 타입에 적합.

---

### **전문 검색 인덱스**

- **알고리즘**:
    - 어근 분석: 단어의 어근을 찾아 검색 효율 향상.
    - n-gram: 단어를 일정 길이로 나눠 검색에 활용.
- **불용어**: 검색에 불필요한 단어를 제거.

---

### **쿼리 최적화**

- 인덱스가 포함된 조건을 적절히 설정해야 최대 효과 발휘.
- WHERE 조건과 일치하지 않는 경우 인덱스 사용이 제한됨.

### **루스(Lose) 인덱스 스캔**

- **루스 인덱스 스캔**은 인덱스의 조건을 만족하지 않는 부분을 건너뛰면서(SKIP) 필요한 데이터만 효율적으로 읽습니다.
- **활용 예**: `GROUP BY` 또는 집합 함수(MAX, MIN) 최적화.
- 인덱스 스캔의 효율성은 쿼리 조건과 생성된 인덱스에 따라 다릅니다.

---

### **다중 컬럼 인덱스**

- 다중 컬럼 인덱스는 2개 이상의 칼럼을 포함하여 결합된 키로 검색을 최적화.
- 칼럼 순서 중요: 인덱스는 **왼쪽부터 순차적으로** 적용되며, 중간 또는 오른쪽만 사용하는 경우 효율성 저하.
- **정렬 방식**: MySQL 8.0은 ASC와 DESC를 혼합하여 인덱스 생성 가능.

---

### **R-Tree 인덱스**

- **공간 데이터**를 다루는 데 적합.
- 위치 기반 데이터를 다룰 때 사용하는 **MBR(Minimum Bounding Rectangle)** 개념을 활용.
- MySQL에서 공간 검색에 유용한 알고리즘 및 데이터 타입(Point, Line, Polygon) 지원.

---

### **전문 검색 인덱스 (Full-Text Index)**

- 텍스트 검색을 위한 인덱스로, 문서 내용에서 키워드 기반 검색에 사용.
- 키워드 분석 방법:
    - **어근 분석(Stemming)**: 단어의 뿌리를 식별.
    - **불용어 처리(Stop Words)**: 검색에 불필요한 단어 제거.
- **n-gram 알고리즘**: 2-gram 방식으로 문장을 나누어 검색 효율 극대화.

---

### **함수 기반 인덱스**

- **가상 칼럼 인덱스**: 새로운 칼럼을 생성하여 저장 및 인덱스화.
    - 예: `full_name` = CONCAT(`first_name`, `last_name`)
- **함수 인덱스**: 테이블 구조를 변경하지 않고 특정 함수에 대해 직접 인덱스를 생성.
    - MySQL 8.0 이상에서 지원.

### **클러스터링 인덱스 (Clustering Index)**

- **특징**:
    - 레코드의 저장 순서가 인덱스 키 값에 의해 결정.
    - 주로 InnoDB에서 사용하며, MyISAM은 지원하지 않음.
- **장점**:
    - 읽기 성능이 우수하며, 데이터의 물리적 정렬이 유지됨.
- **단점**:
    - UPDATE/INSERT 성능 저하.
    - 모든 세컨더리 인덱스에 클러스터링 키 포함으로 메모리 소모 증가.

---

### **MySQL 8.0의 개선 사항**

- **가상 칼럼을 활용한 함수 기반 인덱스**:
    - 테이블 구조를 변경하지 않고도 함수 인덱스를 생성 가능.
    - 예: `CONCAT(first_name, last_name)`로 가상 칼럼 생성 후 인덱스 추가.
- **JSON 기반 멀티 밸류 인덱스**:
    - JSON 배열 요소를 개별 값으로 인덱싱하여 검색 효율성 증가.
- **전문 검색 인덱스의 n-gram 알고리즘**:
    - 텍스트 분석 시 단어를 n-gram으로 나누어 효율적 검색.

---

### **사용자 정의 설정**

- **불용어 처리**:
    - 기본 불용어 리스트를 비활성화하거나 사용자 정의 불용어 리스트를 적용 가능.
    - 설정: `ft_stopword_file` 및 `innodb_ft_user_stopword_table`.
- **자동 증가 키 (AUTO_INCREMENT)**:
    - 기본적으로 프라이머리 키로 설정되지만, 업무에 맞는 별도 키를 사용할 것을 권장.

---

### **주의사항**

- 클러스터링 인덱스의 크기와 AUTO_INCREMENT 키의 설정은 성능과 메모리 사용량에 큰 영향을 미침.
- INSERT/UPDATE/DELETE 작업이 빈번한 테이블에서는 클러스터링 인덱스 사용 시 성능 저하를 고려해야 함.

### **유니크 인덱스**

- **특징**:
    - 유니크 인덱스는 일반 인덱스와 동일한 역할을 수행하면서도 중복 데이터를 허용하지 않음.
    - NULL 허용 여부:
        - MySQL에서는 유니크 인덱스가 NULL을 허용할 수 있으며, NULL 값은 서로 다른 값으로 간주됨.
        - 스토리지 엔진에 따라 NULL 처리 방식이 달라질 수 있음 (예: MyISAM, InnoDB).

---

### **유니크 인덱스와 일반 세컨더리 인덱스의 비교**

- 유니크 인덱스는 데이터 중복 체크 과정이 추가되므로 일반 세컨더리 인덱스보다 쓰기 작업에서 성능이 낮을 수 있음.
- 읽기 성능에서는 두 인덱스 간 구조적 차이가 없어 성능에 큰 영향이 없음.

---

### **인덱스 읽기**

- 유니크 인덱스와 일반 세컨더리 인덱스의 읽기 성능 차이는 미미.
- 레코드 읽기:
    - 1건 읽기에 0.1초 걸릴 경우, 10건은 0.2~0.3초 소요.
    - 디스크 I/O와 CPU 사용이 주요 요소로, 인덱스 유형에 따른 차이는 크지 않음.

---

### **인덱스 쓰기**

- 유니크 인덱스는 데이터 중복 여부를 체크하는 추가 작업이 필요하므로, 쓰기 성능에서 일반 인덱스보다 느림.
- **InnoDB**:
    - Change Buffer 최적화가 적용되지 않음.
    - 중복 체크 과정이 쓰기 성능에 영향을 미침.

---

### **유니크 인덱스 사용 시 주의사항**

- 불필요한 유니크 인덱스를 생성하지 않아야 하며, 이미 유니크 인덱스가 있다면 동일한 컬럼에 일반 인덱스를 중복 생성할 필요 없음.
- 예제 코드:
    
    ```sql
    sql
    코드 복사
    CREATE TABLE tb_unique (
        id INTEGER NOT NULL,
        nick_name VARCHAR(100),
        PRIMARY KEY (id),
        UNIQUE INDEX ux_nickname (nick_name),
        INDEX ix_nickname (nick_name) -- 불필요한 중복
    );
    
    ```
    
    - `ix_nickname` 인덱스는 `ux_nickname`이 동일한 역할을 수행하므로 생성하지 않아도 됨.

---

### **핵심 요약**

1. **유니크 인덱스**는 데이터 중복을 허용하지 않으며, 읽기 성능은 일반 인덱스와 차이가 없으나 쓰기 성능은 낮을 수 있음.
2. **주의사항**:
    - 중복된 일반 인덱스를 생성하지 않도록 설계.
    - 반드시 필요한 경우에만 유니크 인덱스를 활용.
3. **효율적 인덱스 설계**:
    - 유니크 인덱스는 일반 인덱스의 기능을 대체할 수 있으므로, 중복된 인덱스는 피해야 함.

### **외래키**

- **정의 및 특징**:
    - 외래키는 MySQL에서 **InnoDB 스토리지 엔진**에서만 생성 가능.
    - 부모 테이블의 컬럼과 연동하여 데이터 무결성을 유지함.
    - 외래키 제약 조건이 설정되면 자동으로 관련 인덱스가 생성됨.
    - 외래키가 없는 경우, 수작업으로 데이터 무결성을 유지해야 함.

### **InnoDB의 외래키 특징**:

1. 부모-자식 테이블 간의 데이터 참조 무결성을 자동으로 보장.
2. 테이블 변경(INSERT, UPDATE, DELETE) 시 외래키 제약 조건을 검사하여 잠금(lock) 대기가 발생할 수 있음.

---

### **자식 테이블의 변경이 대기하는 경우**

- 부모 테이블이 참조되는 자식 테이블의 외래키 값 변경 시, 부모 테이블에 대한 **잠금 대기** 발생.
- **예제**:
    - `tb_child`의 `pid` 컬럼을 부모 테이블 `tb_parent`의 `id` 컬럼과 연결.
    - 부모 테이블이 변경 중일 때, 자식 테이블의 `pid` 값을 변경하려고 하면 잠금 대기가 발생.

### **작업 흐름**:

1. **트랜잭션 시작**: 부모 테이블(`tb_parent`)의 값을 변경.
2. 자식 테이블(`tb_child`)에서 외래키 값 변경 시, 부모 테이블의 변경 작업 완료 대기.

---

### **부모 테이블의 변경 작업이 대기하는 경우**

- 자식 테이블에서 부모 테이블을 참조하는 레코드가 있는 경우, 부모 테이블의 삭제나 업데이트 시 **잠금 대기** 발생.
- **특성**:
    - `ON DELETE CASCADE` 조건이 설정되었을 때, 부모 테이블 삭제 시 자식 테이블의 연관 레코드도 자동 삭제.

### **작업 흐름**:

1. 부모 테이블 삭제 시, 자식 테이블에서 외래키 참조를 제거하는 작업이 동시에 수행.
2. 부모 테이블 삭제가 자식 테이블 작업에 의해 지연될 수 있음.

---

### **요약**

1. **외래키의 장점**:
    - 데이터 무결성 보장.
    - 참조 관계 자동 관리(`ON DELETE`, `ON UPDATE` 등 조건 활용).
2. **주의사항**:
    - 외래키로 인해 부모-자식 테이블 간 잠금 대기가 발생할 수 있음.
    - 데이터 모델 설계 시, 잠금 대기 현상을 고려하여 물리적 외래키 사용 여부를 판단해야 함.