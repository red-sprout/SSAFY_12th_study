## 1. 랜덤 I/O와 순차 I/O의 차이점은 무엇이며, 데이터베이스 성능 튜닝에서 중요한 이유는 무엇인가요?
(8.1 디스크 읽기 방식)

랜덤 I/O는 디스크 헤더가 여러 위치로 이동하며 데이터를 읽는 방식으로, 한 번의 요청에 여러 디스크 접근이 필요합니다.

반면, 순차 I/O는 데이터가 연속적으로 저장되어 한 번의 연속적인 디스크 읽기로 처리가 가능해 훨씬 빠릅니다.

데이터베이스에서 대부분의 작업은 랜덤 I/O를 통해 작은 데이터를 빈번히 읽고 쓰기 때문에, 랜덤 I/O를 줄이는 것이 성능 튜닝의 핵심입니다.
이를 위해 쿼리를 최적화하여 필요한 데이터만 읽도록 개선해야 합니다.

- 랜덤 I/O
  - :데이터가 디스크의 여러 위치에 흩어져 있어 헤더를 이동시키며 데이터를 읽는 방식.
  - 여러 번의 디스크 접근이 필요해 시간이 오래 걸림.
- 순차 I/O
  - :데이터가 연속적으로 저장되어 한 번의 디스크 접근으로 데이터를 읽는 방식.
  - 디스크 헤더 이동 없이 연속 읽기가 가능해 빠름.

- 중요성
  - 대부분의 데이터베이스 작업은 랜덤 I/O 기반이며, 이는 디스크 성능의 병목을 초래할 수 있음.
  - 성능 튜닝의 핵심은 랜덤 I/O를 줄이고 필요한 데이터만 읽도록 쿼리를 최적화하는 것.

---

## 2. B-Tree 인덱스와 Hash 인덱스의 차이점을 설명하고, 각각의 사용 사례를 제시하세요.
(8.2 인덱스란?)

B-Tree 인덱스는 데이터가 정렬된 상태로 유지되어 범위 검색과 순차 검색에 적합합니다.

예를 들어, 나이 조건으로 검색(WHERE age BETWEEN 20 AND 30)하는 경우 B-Tree가 유리합니다.

반면, Hash 인덱스는 해시값을 기반으로 키-값 검색이 빠르지만 범위 검색은 불가능합니다.

고유한 ID를 이용한 검색(WHERE id = '12345')에 적합합니다.

- B-Tree 인덱스
  - 데이터가 정렬된 상태로 유지됨.
  - 범위 검색, 순차 검색에 적합.
  - 예: SELECT ... WHERE age BETWEEN 20 AND 30.
- Hash 인덱스
  - 데이터의 해시값을 기반으로 빠른 키-값 검색 제공.
  - 범위 검색 불가.
  - 예: SELECT ... WHERE id = '12345'.
- 차이점
  - B-Tree는 정렬된 데이터로 범위 검색 가능, Hash는 키-값 검색에 최적화.
  - B-Tree는 디스크 기반, Hash는 메모리 기반에 주로 사용.

---

## 3. 인덱스 키 값의 크기가 데이터베이스 성능에 미치는 영향을 설명하세요.
(8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소)

인덱스 키 값이 클수록 한 페이지에 저장할 수 있는 키의 수가 줄어들어 디스크 읽기 횟수가 증가하게 됩니다.

또한, 인덱스의 전체 크기가 커져 메모리 캐시 효율이 낮아지고, 성능이 저하됩니다.

예를 들어, 페이지 크기가 16KB이고 키 값이 16바이트일 때 한 페이지에 약 585개의 키가 저장됩니다.

키 크기가 32바이트로 증가하면 저장 가능한 키의 수가 약 372개로 줄어들어 더 많은 디스크 읽기가 필요하게 됩니다.

- 영향
  - 키 값이 클수록 한 페이지에 저장 가능한 키 수가 줄어들어 디스크 I/O가 증가함.
  - 인덱스 크기가 커지면 캐시 효율성이 낮아지고, 메모리 사용량 증가로 성능 저하.
- 예시
  - 16바이트 키 값: 한 페이지에 585개 키 저장 가능.
  - 32바이트 키 값: 한 페이지에 372개 키 저장 가능 → 디스크 읽기 횟수 증가.

---

## 4. 다중 컬럼 인덱스에서 컬럼 순서가 중요한 이유는 무엇인가요?
(8.3.5 다중 컬럼 인덱스)

다중 컬럼 인덱스는 첫 번째 컬럼을 기준으로 정렬되며, 이후 컬럼은 앞의 컬럼에 의존적으로 정렬됩니다.

따라서 첫 번째 컬럼에 조건이 없거나 범위 조건만 있을 경우, 이후 컬럼 인덱스가 무효화될 수 있습니다.

예를 들어, INDEX (A, B)가 있을 때 WHERE B = ?로만 조건을 주면 인덱스를 효과적으로 사용할 수 없습니다.

따라서 인덱스 설계 시 자주 사용되거나 선택도가 높은 컬럼을 앞에 배치해야 합니다.

---

## 5. R-Tree 인덱스의 구조와 B-Tree 인덱스의 주요 차이점은 무엇인가요?
(8.4 R-Tree 인덱스)

R-Tree 인덱스는 공간 데이터를 다루기 위해 MBR(Minimum Bounding Rectangle)을 사용하며, 2차원 데이터(예: 위도와 경도)를 처리할 수 있습니다.
특정 반경 내 데이터를 검색하거나 다각형과의 교차 여부를 판단하는 데 적합합니다.

반면, B-Tree 인덱스는 1차원 데이터를 정렬하여 범위 검색과 순차 검색에 사용됩니다. 예를 들어, 날짜 범위 검색에서 효과적입니다.
R-Tree는 공간 데이터, B-Tree는 정렬된 데이터에 적합하다는 점이 차이입니다.

- R-Tree
  - 공간 데이터를 처리하기 위해 MBR(Minimum Bounding Rectangle) 사용.
  - 2차원 좌표 데이터를 인덱싱.
  - 예: 특정 좌표 범위 내 검색.
- B-Tree
  - 1차원 데이터를 정렬하여 범위 및 순차 검색.
  - 예: 날짜나 숫자 범위 검색.
- 차이점: R-Tree는 2차원 공간 데이터를 다루며, B-Tree는 1차원 데이터를 다룸.

---

## 6. 전문 검색 인덱스에서 n-gram 알고리즘이 사용되는 이유와 장단점을 설명하세요.
(8.5 전문 검색 인덱스)

n-gram 알고리즘은 텍스트 데이터를 작은 조각(n-gram)으로 나눠 빠르게 검색할 수 있도록 설계된 방식입니다.

장점으로는 빠른 검색 속도와 특정 키워드 검색에 유리하다는 점이 있으며, 단점으로는 인덱스 크기가 증가하여 저장 공간을 많이 차지할 수 있다는 점이 있습니다.

예를 들어, 텍스트 데이터에서 특정 키워드가 포함된 문서를 빠르게 찾는 데 효과적입니다.

- 이유: 텍스트 데이터를 몇 글자씩 잘라 빠르게 검색할 수 있도록 인덱싱.
- 장점
  - 빠른 검색 속도.
  - 특정 키워드나 텍스트 조각 검색에 적합.
- 단점
  - 인덱스 크기 증가.
  - 불필요한 키워드로 인해 과도한 저장 공간 사용 가능.

---

## 7. 왜 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현되어 있나요?
(8.8.2 세컨더리 인덱스에 미치는 영향)

세컨더리 인덱스는 프라이머리 키 값을 저장함으로써 데이터의 위치가 변경될 때 모든 세컨더리 인덱스를 업데이트해야 하는 오버헤드를 방지합니다.
프라이머리 키는 논리적 참조 역할을 하므로, 데이터 이동 시에도 안정성을 유지합니다. 또한, 고정된 크기의 프라이머리 키를 사용하면 저장 공간을 절약할 수 있습니다.

- 데이터 위치 변경: 레코드 이동 시 물리적 주소를 저장하면 세컨더리 인덱스를 모두 업데이트해야 함.
- 오버헤드 감소: 프라이머리 키를 저장하면 클러스터링 키로 논리적 참조 가능, 주소 갱신 비용 절감.
- 공간 효율성: 프라이머리 키는 고정된 크기로, 저장 공간을 절약함.

---

## 8. 클러스터링 인덱스의 장단점을 설명하세요.
(8.8.3 클러스터링 인덱스의 장점과 단점)

- 장점
  - 프라이머리 키 기반의 검색이 매우 빠릅니다.
  - 세컨더리 인덱스도 프라이머리 키를 참조하므로 효율적으로 작동합니다.
- 단점
  - 프라이머리 키 크기가 클 경우 세컨더리 인덱스 크기도 커져 성능이 저하됩니다.
  - 프라이머리 키 변경 시, 레코드 이동으로 인해 처리 성능이 떨어질 수 있습니다.

---

## 9. MySQL에서 유니크 인덱스를 사용하는 경우 주의해야 할 점은 무엇인가요?
(8.9 유니크 인덱스)

유니크 인덱스는 삽입 시 중복 여부를 확인하는 작업이 추가되어 성능이 저하될 수 있습니다. 또한, 이 과정에서 읽기/쓰기 잠금으로 인해 데드락이 발생할 위험이 있습니다.
불필요한 유니크 인덱스를 생성하지 않고, 동일한 컬럼에 프라이머리 키와 유니크 인덱스를 중복 생성하지 않도록 주의해야 합니다.

- 중복 체크 비용: 삽입 시 중복 여부 확인 작업이 추가되어 성능 저하 가능.
- 데드락 발생: 중복 체크 과정에서 읽기/쓰기 잠금으로 인해 데드락 위험 증가.
- 불필요한 생성 방지: 프라이머리 키와 동일한 유니크 인덱스 생성은 중복이므로 비효율적.

---

## 10. MySQL에서 외래키 제약 조건이 성능에 미치는 영향을 설명하세요.
(8.10 외래키)

외래키 제약은 부모-자식 테이블 간 변경 작업 시 잠금 경합이 발생할 수 있습니다.
부모 테이블의 변경 작업이 완료되기 전까지 자식 테이블이 대기 상태가 되며, 이는 동시 처리 성능 저하로 이어질 수 있습니다.
외래키 대신 애플리케이션 로직으로 데이터 무결성을 관리하거나, 모델링 단계에서 외래키 사용 여부를 신중히 결정해야 합니다.

- 영향
  - 잠금 경합: 부모-자식 테이블 간 변경 작업 시 대기 발생.
  - 잠금 확장: 외래키 체크를 위해 연관 테이블에도 잠금이 걸려 동시 처리 성능 저하.
- 주의점
  - 모델링 단계에서 외래키 사용 여부를 신중히 결정.
  - 외래키 없이 애플리케이션 로직으로 무결성을 관리하는 방법도 고려.

---
