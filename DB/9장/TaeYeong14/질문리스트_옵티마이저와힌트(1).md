# 9장 옵티마이저와 힌트 - 9.1 개요, 9.2 기본 데이터 처리

## 1. SQL 파싱이란 무엇이며, 어떤 단계에서 이루어지나요?

SQL 파싱은 MySQL 서버가 SQL 문장을 이해할 수 있도록 분해하고 구조화하는 단계입니다.  
- **파싱 트리**를 생성하여 SQL 문법 오류를 확인합니다.  
- 파싱된 정보는 옵티마이저 단계로 넘어가 실행 계획을 세우는 데 사용됩니다.  
이 단계는 SQL 실행 절차의 첫 번째 단계로, 이후 쿼리 최적화 및 실행으로 이어집니다.

---

## 2. 옵티마이저가 실행 계획을 생성할 때 어떤 요소를 고려하나요?

옵티마이저는 다음 요소를 고려하여 실행 계획을 생성합니다:  
1. **테이블 읽기 순서**: 여러 테이블이 조인될 경우 어떤 순서로 읽을지 결정합니다.  
2. **인덱스 선택**: 각 테이블에서 사용 가능한 조건과 인덱스를 분석하여 최적의 인덱스를 선택합니다.  
3. **조인 방식**: Nested Loop Join, Hash Join 등 조인 방법을 선택합니다.  
4. **조건 단순화**: 불필요한 조건을 제거하고 복잡한 연산을 단순화합니다.  
5. **통계 정보**: 테이블과 인덱스의 통계를 분석하여 비용을 산출합니다.  
이 모든 과정을 통해 최소 비용의 실행 계획을 세웁니다.

---

## 3. 규칙 기반 최적화(RBO)와 비용 기반 최적화(CBO)의 차이점은 무엇인가요?

- **규칙 기반 최적화(RBO):**  
  사전에 정의된 규칙에 따라 쿼리를 실행하며, 데이터 분포도나 통계 정보를 고려하지 않습니다.  
  항상 동일한 실행 방법을 사용하므로 단순한 쿼리에 적합하지만, 최신 데이터베이스에서는 잘 사용되지 않습니다.  

- **비용 기반 최적화(CBO):**  
  실행 가능한 여러 방법의 비용을 계산하고, 가장 비용이 적은 실행 계획을 선택합니다.  
  테이블의 통계 정보와 인덱스를 활용하므로 복잡한 쿼리에 적합합니다.  
현대의 MySQL 옵티마이저는 대부분 CBO를 사용합니다.

---

## 4. 풀 테이블 스캔이 선택되는 경우는 언제인가요?

풀 테이블 스캔은 다음 경우에 선택됩니다:  
1. **레코드 수가 적은 경우**: 테이블 전체를 읽는 것이 효율적입니다.  
2. **인덱스를 활용할 조건이 없는 경우**: WHERE 절에 인덱스가 사용되지 않으면 전체 테이블을 스캔해야 합니다.  
3. **조건 일치 레코드가 많을 경우**: 옵티마이저가 인덱스보다 풀 테이블 스캔이 더 빠르다고 판단합니다.  

InnoDB 스토리지 엔진은 리드 어헤드(Read Ahead)를 통해 풀 테이블 스캔의 성능을 향상시킬 수 있습니다.

---

## 5. 싱글 패스 정렬과 투 패스 정렬의 차이점은 무엇이며, 각각 언제 사용되나요?

- **싱글 패스 정렬:**  
  정렬 기준 칼럼과 SELECT 대상 칼럼을 모두 메모리에 담아 정렬합니다.  
  일반적으로 사용되며 성능이 뛰어납니다.

- **투 패스 정렬:**  
  정렬 기준 칼럼과 프라이머리 키만 정렬한 뒤, 해당 순서대로 테이블에서 나머지 칼럼을 가져옵니다.  
  **사용 사례:**  
  - 레코드 크기가 `max_length_for_sort_data`보다 큰 경우  
  - BLOB이나 TEXT 타입 칼럼이 포함된 경우

---

## 6. Filesort와 인덱스를 이용한 정렬의 장단점을 비교하세요.

- **인덱스를 이용한 정렬:**  
  - 장점: 이미 정렬된 데이터를 읽기만 하면 되므로 빠릅니다.  
  - 단점: 추가적인 인덱스 생성/관리 비용과 디스크 공간이 필요합니다.  

- **Filesort:**  
  - 장점: 인덱스를 생성하지 않아도 되므로 유연합니다.  
  - 단점: 정렬 대상이 많을 경우 성능 저하가 발생할 수 있습니다.  
Filesort는 인덱스를 사용할 수 없는 경우에 주로 사용됩니다.

---

## 7. 루스 인덱스 스캔이란 무엇이며, 사용되지 않는 쿼리 패턴은 어떤 것이 있나요?

루스 인덱스 스캔은 인덱스 레코드를 건너뛰며 필요한 값만 읽는 방식으로, 유니크한 값이 적을수록 성능이 향상됩니다.  
사용되지 않는 패턴은 다음과 같습니다:  
1. MIN, MAX 외의 집합 함수 사용  
2. GROUP BY 칼럼이 인덱스 구성의 왼쪽부터 일치하지 않는 경우  
3. SELECT 절의 칼럼이 GROUP BY와 일치하지 않는 경우

---

## 8. SELECT DISTINCT와 GROUP BY는 어떤 방식으로 처리되며, 둘 사이의 차이는 무엇인가요?

- **SELECT DISTINCT:**  
  전체 SELECT 대상이 유니크하도록 처리합니다.  
  예를 들어, `SELECT DISTINCT col1, col2`는 `(col1, col2)` 조합이 유니크해야 합니다.

- **GROUP BY:**  
  특정 칼럼별로 그룹화하여 집합 연산을 수행합니다.  
  DISTINCT는 유니크한 값을 반환하는 데 초점이 있지만, GROUP BY는 집합 함수와 함께 사용되는 경우가 많습니다.

---

## 9. 임시 테이블이 디스크에 생성되는 조건은 무엇인가요?

임시 테이블이 디스크에 생성되는 조건은 다음과 같습니다:  
1. UNION이나 GROUP BY로 반환되는 칼럼 크기가 512바이트 이상  
2. 메모리 임시 테이블 크기가 `tmp_table_size`나 `max_heap_table_size`를 초과  
3. DISTINCT와 ORDER BY가 동시에 사용된 경우

---

## 10. Created_tmp_table과 Created_tmp_disk_tables 상태 변수의 차이점은 무엇인가요?

- **Created_tmp_table:**  
  모든 임시 테이블(메모리와 디스크 포함)의 누적 개수를 기록합니다.  

- **Created_tmp_disk_tables:**  
  디스크에 생성된 임시 테이블 개수만 누적합니다.  
이 변수들은 쿼리 성능을 최적화하거나 메모리 부족 문제를 진단하는 데 유용합니다.
