# 9.1 개요

## 9.1.1 쿼리 실행 절차

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)
    - SQL Parsing, SQL 문장이 문법적으로 잘못되었다면 이 부분에서 확인
    - MySQL 서버는 SQL 파스 트리로 쿼리 실행
2. SQL 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
    - 불필요한 조건 제거 및 복잡한 연산의 단순화
    - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
    - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
    - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
    - **옵티마이저**에서 처리 → 실행 계획이 형성됨
3. 앞 단계의 테이블 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴
    - 1, 2단계 : MySQL 엔진, 3단계 : MySQL + 스토리지 엔진

## 9.1.2 옵티마이저의 종류

- 규칙 기반 최적화(Rule-based optimizer, RBO)
    - 옵티마이저 내장 우선순위에 따름
    - 같은 쿼리에 대해서는 거의 항상 같은 실행 방법
    - 데이터 분포도의 다양성으로 최근에는 거의 사용되지 않음
- 비용 기반 최적화(Cost-based optimizer, CBO)
    - 쿼리를 처리하기 위한 여러 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용 산출
    - CPU 연산의 단점 대신 사용

# 9.2 기본 데이터 처리

## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

- 풀 테이블 스캔 선택
    - 테이블 레코드 수가 너무 적은 경우
    - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
    - 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- MyISAM vs InnoDB
    - InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(Read Ahead) 작업이 자동으로 시작
        - `리드 어헤드` : 요청이 오기 전 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것
        - 리드 어헤드는 풀 인덱스 스캔에서도 동일하게 사용

## 9.2.2 병렬 처리

## 9.2.3 ORDER BY 처리(Using filesort)

- 인덱스 이용
    - 장점
        - INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬되어 있어서 순서대로 읽기만 하면 되므로 매우 빠름
    - 단점
        - INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요
        - 인덱스 때문에 디스크 공간이 더 많이 필요
        - 인덱스의 개수가 늘어날수록 InnoDB의 버퍼 풀을 위한 메모리가 많이 필요하다.
    - 사용 못하는 경우
        - 정렬 기준이 너무 많음
        - GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬
        - 임시 테이블의 결과를 다시 정렬
        - 랜덤하게 결과 레코드를 가져와야 되는 경우
- Filesort 이용
    - 장점
        - 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 변경
        - 정렬해야 될 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다.
    - 단점
        - 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.

### 9.2.3.1 소트 버퍼

- 정렬을 수행하기 위한 별도의 메모리 공간
- 커넥션이 많으면 많을수록, 정렬 작업이 많으면 많을수록 소트 버퍼로 소비되는 메모리 공간이 커짐
    
    → 메모리 부족 현상 → 운영체제의 OOM-Killer가 MySQL 서버 1순위로 종료
    

### 9.2.3.2 정렬 알고리즘

- 싱글 패스 정렬
    - 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 모두 담아서 정렬을 수행하는 정렬방식
- 투 패스 정렬
    - 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT 할 칼럼을 가져오는 정렬 방식
    - 최근에는 일반적으로 싱글 패스 정렬 사용. but, 예외 존재
        - 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 때
        - BLOB이나 TEXT 타입의 칼럼이 SELECT 대상에 포함될 때

### 9.2.3.3 정렬 처리 방법

- 인덱스를 사용한 정렬
    - ORDER BY 에 명시된 칼럼이 제일 먼저 읽는 테이블에 속함
    - ORDER BY 순서대로 생성된 인덱스 있어야 됨
    - B-Tree 계열 인덱스 한정
    - MySQL 엔진에서 별도 정렬을 위한 추가 작업 없음
    - 조인이 사용된 쿼리의 실행 계획에 조인 버퍼가 사용 되면 순서 흐트러질 수 있기에 주의
    
    ```sql
    SELECT *
    FROM employees e, salaries s
    WHERE s.emp_no = e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100020
    ORDER BY e.emp_no;
    ```
    
- 조인에서 드라이빙 테이블만 정렬 : `Using filesort` 메시지 표시
    - 조인 실행 전 첫번째 테이블의 레코드를 먼저 정렬 후 조인 실행
    
    ```sql
    SELECT *
    FROM employees e, salaries s
    WHERE s.emp_no = e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100020
    ORDER BY e.last_name;
    ```
    
- 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 : `Using temporary; Using filesort` 메시지 표시
    - 2개 이상의 테이블을 조인해서 정렬 시 임시 테이블 필요할 수 있음
    - 가장 느린 정렬
    - 드라이빙 테이블이 아닌 드리븐 테이블 칼럼 기준
        - 정렬 수행 전 드리븐 테이블을 읽어야 함
        - 조인된 데이터를 가지고 정렬하는 것이 필수
    
    ```sql
    SELECT *
    FROM employees e, salaries s
    WHERE s.emp_no = e.emp_no
    AND e.emp_no BETWEEN 100002 AND 100020
    ORDER BY s.salary;
    ```
    
- 성능
    - 스트리밍 방식
        - 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식
        - 첫번째 레코드는 빠르게 받음. 마지막은 언제인지 모름
        - 웹 서비스와 같은 OLTP(Online Transaction Processing, 인터넷을 통해 많은 사람들이 많은 데이터베이스 트랜잭션을 실시간으로 실행) → 빠른 응답이 중요
    - 버퍼링 방식
        - ORDER BY, GROUP BY : 정렬이나 그루핑 후에 보내야 됨 - 스트리밍 불가능 - 버퍼링

## 9.2.4 GROUP BY 처리

### 9.2.4.1 인덱스 스캔

- 추가적인 작업 X

### 9.2.4.2 루스 인덱스 스캔

- 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것
- 인덱스의 유니크한 값의 수가 적을수록 성능 향상
- 루스 인덱스 스캔이 안되는 쿼리 패턴

```sql
-- MIN, MAX 이외의 집합 함수 사용
SELECT col1, SUM(col2) FROM tb_test GROUP BY col1;
-- GROUP BY에 사용된 칼럼이 인덱스 구성 칼럼의 왼쪽부터 일치하지 않기 때문에 사용 불가
SELECT col1, col2 FROM tb_test GROUP BY col2, col3;
-- SELECT 절의 칼럼이 GROUP BY와 일치하지 않기 때문에 사용 불가
SELECT col1, col3 FROM tb_test GROUP BY col1, col2;
```

### 9.2.4.3 임시 테이블 사용

- 인덱스를 전혀 사용하지 못할 때 사용하는 방식
- GROUP BY 가 필요한 경우 내부적으로 해당 칼럼들고 구성된 유니크 인덱스를 가진 임시 테이블을 만들어서 중복 제거와 집합 함수 연산을 수행 → 별도 정렬 작업 없음
- ORDER BY 가 같이 사용 되면 명시적으로 정렬 작업을 실행

## 9.2.5 DISTINCT 처리

### 9.2.5.1 SELECT DISTINCT

- GROUP BY 와 동일한 방식으로 처리
- (주의) DISTINCT 는 SELECT 하는 레코드를 유니크하게 선택하는 것 → 특정 칼럼만 X
    - 조회되는 모든 칼럼에 영향을 미침
    
    ```sql
    --(first_name, last_name) 조합 전체가 유니크한 레코드 가져오기
    SELECT DISTINCT first_name, last_name FROM employees;
    ```
    

### 9.2.5.2 집합 함수와 함께 사용되는 DISTINCT

- SELECT와 다르게 집합 함수로 전달된 인자에 해당하는 칼럼 값이 유니크 한 것들을 가져옴

```sql
EXPLAIN SELECT COUNT(DISTINCT s.salary)
FROM employees e, salaries s
WHERE e.emp_no = s.emp_no
AND e.emp_no BETWEEN 100001 AND 100100;
```

## 9.2.6 내부 임시 테이블 활용

### 9.2.6.1 메모리 임시 테이블과 디스크 임시 테이블

- MMAP 파일로 디스크에 기록
- InnoDB 테이블로 기록

### 9.2.6.2 임시 테이블이 필요한 쿼리

- ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTINCT가 사용된 쿼리(select_type 칼럼이 UNION RESULT인 경우)
- 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리

### 9.2.6.3 임시 테이블이 디스크에 생성되는 경우

- UNION이나 UNION ALL에서 SELECT되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
- GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
- 메모리 임시 테이블의 크기가 (MEMORY 스토리지 엔진에서) tmp_table_size 또는 max_heap_table_size 시스템 변수보다 크거나 (TempTable 스토리지 엔진에서) template_max_ram 시스템 변수 값보다 큰 경우

### 9.2.6.4 임시 테이블 관련 상태 변수

- Created_tmp_table : 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값. 해당 값은 내부 임시 테이블이 메모리에 만들어졌는지 디스크에 만들어졌는지를 구분하지 않고 모두 누적한다.
- Created_tmp_disk_tables : 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 가지고 있는 상태 값
