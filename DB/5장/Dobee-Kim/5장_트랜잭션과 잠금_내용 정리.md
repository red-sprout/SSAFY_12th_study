# Real My SQL 5장 트랜잭션과 잠금

# 05 트랜잭션과 잠금

- 트랜잭션 : 작업의 완전성을 보장해주는 것.
    - 논리적인 작업 셋을 모두 완벽하게 처리
    - 처리하지 못할 경우 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 하는 것
- 잠금 vs 트랜잭션
    - 잠금 : 동시성을 제어하기 위한 기능
        - 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할
    - 트랜잭션 : 데이터의 정합성을 보장하기 위한 기능
    - 격리수준 : 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨

## 5.1 트랜잭션

- MyISAM과 MEMORY : 트랜잭션을 지원하지 않음
- InnoDB : 트랜잭션 지원 → 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만듦

<aside>
📌

MyISAM과 MEMORY가 트랜잭션을 지원하지 않는다면, 해당 스토리지 엔진을 사용하는 이유는?

**MyISAM**과 **MEMORY** 스토리지 엔진은 트랜잭션이 필요하지 않은 작업에 초점을 맞춘 엔진입니다.

- **MyISAM**은 빠른 읽기 성능과 단순한 구조 덕분에 **로그 분석**이나 **통계 데이터 저장** 등 읽기 중심의 작업에서 유리합니다.
- **MEMORY**는 데이터를 **메모리**에 저장하기 때문에 접근 속도가 매우 빠릅니다. 따라서 임시 테이블, 세션 데이터 저장, 빠른 캐싱이 필요할 때 주로 사용됩니다.

트랜잭션을 지원하지 않아도 성능이 중요한 환경에서는 이러한 스토리지 엔진이 최적의 선택이 될 수 있습니다.

</aside>

### 주의사항

- 프로그램 코드에서 트랜잭션의 범위를 최소화할 것
    - 데이터베이스 커넥션의 개수는 제한적 → 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션의 개수는 줄어들 것
    - 메일전송 FTP파일 전송 작업, 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 DBMS 트랜잭션 내에서 제거할 것 → 프로그램 실행동안 메일 서버와 통신할 수 없는 상황이 발생하면, 웹서버뿐만 아니라 DBMS 서버까지 위험해짐

<aside>
📌

커넥션의 개수는 어떻게 지정하는지?

커넥션의 수를 늘리고, 줄이면 어떻게 되는가?

- **커넥션의 개수 설정:**
    
    MySQL에서는 `max_connections` 변수를 통해 최대 커넥션 수를 지정할 수 있습니다. 예를 들어, `SET GLOBAL max_connections = 200;` 명령어로 최대 연결 수를 200으로 설정할 수 있습니다.
    
    설정된 값은 데이터베이스 성능과 서버의 자원에 따라 결정됩니다.
    
- **커넥션 수를 늘리면:**
    
    더 많은 사용자나 애플리케이션이 동시에 연결할 수 있습니다. 그러나 커넥션이 증가하면 메모리 사용량이 급증하고, CPU 부담이 늘어나 **성능 저하**를 초래할 수 있습니다.
    
- **커넥션 수를 줄이면:**
    
    자원 사용이 감소해 서버 안정성을 높일 수 있지만, 동시 접속 가능한 사용자 수가 제한됩니다. 이로 인해 **연결 대기 시간**이 증가할 수 있습니다.
    
</aside>

![image.png](image.png)

## 5.2 MySQL 엔진의 잠금

- 스토리지 엔진 레벨
    - 상호영향
- MySQL 엔진 레벨 : MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분
    - 해당 레벨 잠금은 모든 스토리지 엔진에 영향을 미침
- 글로벌 락
- 네임드 락
    - GET_LOCK() 함수를 이용해 임의의 문자열에 대한 잠금 설정 가능
- 메타데이터 락
    - 데이터베이스 객체의 이름이나 구조를 변경하는경우 흭득하는 잠금

## 5.3 InnoDB 스토리지 엔진 잠금

- 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재
    - 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서 사용되는 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기 상당히 까다로움

<aside>
📌

장점과 효과는?
InnoDB는 레코드 기반의 잠금 방식을 사용하여 **동시성**을 높이고 **데이터 무결성**을 보장합니다.

- **장점:**
    - 테이블 전체를 잠그는 MyISAM과 달리 필요한 레코드 단위만 잠금 처리하여 **동시 처리 성능**이 향상됩니다.
    - **MVCC**를 통해 READ 작업 시 다른 트랜잭션에 방해받지 않고 데이터를 일관되게 읽을 수 있습니다.
    - 갭 락, 넥스트 키 락 등의 잠금 방식을 통해 PHANTOM READ와 같은 문제를 해결합니다.
- **효과:**
    - 트랜잭션 처리 시 불필요한 대기 시간이 줄어들고, **동시 실행률**이 높아져 시스템 성능이 최적화됩니다.
    - 데이터의 무결성과 정합성을 보장하면서도 다중 사용자 환경에서 원활하게 동작합니다.
</aside>

![image.png](image%201.png)

- 레코드 락
    - 레코드 자체만을 잠그는 것
    - InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠금
    - 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금 설정
- 갭 락
    - 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것
    - 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어함
    - 넥스트 키 락의 일부로 사용됨
- 넥스트 키 락
    - 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
    
    ### **갭 락과 넥스트 키 락의 차이점**
    
    | 구분 | **갭 락** | **넥스트 키 락** |
    | --- | --- | --- |
    | 잠금 대상 | 레코드 사이의 **간격(갭)** | **레코드 + 레코드 주변의 간격** |
    | 사용 목적 | PHANTOM READ 방지, 새 레코드 삽입 방지 | PHANTOM READ 완전 방지 |
    | 적용 범위 | 레코드 간격만 잠금 | 레코드와 인접 간격을 모두 잠금 |
    | 잠금 강도 | 상대적으로 약함 | 더 강력함 |
    
    ![image.png](image%202.png)
    
- 자동 증가 락
    - AUTO_INCREMENT 칼럼이 사용된 테이블에 여러 레코드가 INSERT 되는 경우 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 함
        - AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금 사용
    - INSERT, REPLACE와 같이 새로운 레코드를 저장하는 쿼리에서만 필요
    - AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제
    - 해당 락은 테이블에서 단 하나만 존재하기 때문에, 두개의 INSERT 쿼리가 동시에 실행될 경우, 하나의 쿼리가 해당 락을 걸면, 나머지 쿼리는 락을 기다려야 함
    - 아주 짧은 시간동안 걸렸다가 해제되는 잠금, 명시적으로 획득하고 해제하는 방법은 없음

![image.png](image%203.png)

### 인덱스와 잠금

- InnoDB의 잠금은 레코드를 잠그는 것이 아닌, 인덱스를 잠그는 방식으로 처리됨
    - 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락 걸어야 함
    - 인덱스 설계가 중요한 이유이기도 함
    
    ![image.png](image%204.png)
    

### 레코드 수준의 잠금 확인 및 해제

- MySQL 5.1 버전부터 레코드 잠금과 잠금 대기에 대한 조회가 가능
- 테이블 수준의 잠금이 아닌, 레코드 각각에 잠금이 걸리므로, 레코드가 자주 사용되지 않는다면 오랜 시간동안 잠겨진 상태로 남아 있어도 잘 발견되지 않음

<aside>
📌

잠금 상태로 남아있으면 생기는 문제는 무엇?
잠금이 오랜 시간 해제되지 않은 상태로 남아 있으면 다음과 같은 문제가 발생할 수 있습니다.

1. **데드락 (Deadlock):** 두 개 이상의 트랜잭션이 서로의 잠금을 기다리며 진행되지 못하는 상태입니다.
2. **성능 저하:** 다른 트랜잭션이 잠금이 해제될 때까지 기다리기 때문에 전체 시스템의 성능이 저하됩니다.
3. **리소스 낭비:** 잠금을 기다리는 트랜잭션이 많아질수록 데이터베이스의 리소스(메모리, CPU)가 불필요하게 소모됩니다.
4. **서비스 지연:** 잠금 상태가 지속되면 사용자의 요청이 지연되거나 실패하게 되어 시스템의 가용성이 떨어집니다.

이를 방지하기 위해 잠금 타임아웃 설정(`innodb_lock_wait_timeout`)을 통해 일정 시간이 지나면 트랜잭션을 강제로 종료하도록 설정할 수 있습니다.

</aside>

## 5.4 MySQL의 격리 수준

- 트랜잭션의 격리 수준
    - 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것
    
    ![image.png](image%205.png)
    

### READ UNCOMMITTED

![image.png](image%206.png)

- Dirty Read : 어떤 트랜잭션에 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상
- 더티 리드가 허용되는 격리수준
- 정합성에 문제가 많은 격리 수준

### READ COMMITTED

![image.png](image%207.png)

- 오라클 DBMS에서 기본으로 사용되는 격리 수준, 온라인 서비스에서 가장 많이 선택되는 격리 수준
- 어떤 트랜잭션에서 변경한 내용이 커밋되기 전까지는 다른 트랜잭션에서 그러한 변경 내역을 조회할 수 없음

![image.png](image%208.png)

- NON-REPEATABLE READE 부정합 문제가 있음
    - 사용자가 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 REPEATABLE READ 정합성에 어긋남
    - 하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수 있음

### REPEATABLE READ

![image.png](image%209.png)

- InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준
- 바이너리 로그를 가진 MySQL 서버에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야함

<aside>
📌

이유가 뭘까?
바이너리 로그는 **데이터베이스 변경 이력**을 기록하는 기능으로, 복제나 백업 시 사용됩니다.

- **REPEATABLE READ**는 트랜잭션 중 동일한 데이터를 여러 번 조회해도 일관된 결과를 반환합니다. 이는 **MVCC**를 통해 언두 공간에 백업된 데이터를 이용하기 때문입니다.
- 격리 수준이 낮은 READ COMMITTED에서는 동일 트랜잭션 내에서 데이터가 변경될 가능성이 있어 **바이너리 로그에 일관되지 않은 변경 이력**이 기록될 수 있습니다.

따라서 바이너리 로그를 사용하는 MySQL 서버는 **REPEATABLE READ** 이상을 사용해야 트랜잭션 간의 정합성과 변경 이력의 일관성을 보장할 수 있습니다.

</aside>

- NON-REPEATABLE READ 부정합이 발생하지 않음
    - InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경함 → MVCC(Multi Version COncurrency Control)
    - REPEATABLE READE는 이MVCC를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장함
    - 모든 InnoDB 트랜잭션은 고유한 트랜잭션 번호를 가짐 → 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션 번호가 포함되어 있음
    - 언두 영역의 백업된 데이터틑 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제함
    - 언두에 백업된 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있으니 주의할 것

![image.png](image%2010.png)

![image.png](image%2011.png)

- PHANTOM READ : 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상 → 부정합이 일어날 수 있음

### SERIALIZABLE

- 가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준
- 처리 성능도 다른 트랜잭션 격리 수준보다 떨어짐
- 보통 InnoDB 테이블에서는 기본적으로 순수한 SELECT 작업만 레코드 잠금이 설정하지 않고 실행됨
    - 읽기 작업도 공유 잠금을 흭득해야 하고, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 됨
    - 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없음
- InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE REAd 격리 수준에서도 이미 PHANTOM READ 가 발생하지 않기 때문에 SERIALZABLE을 사용할 필요성은 없음

<aside>
📌

어째서?
InnoDB 스토리지 엔진은 **갭 락(Gap Lock)**과 **넥스트 키 락(Next-Key Lock)**을 통해 PHANTOM READ를 방지합니다.

- **갭 락:** 레코드 간의 간격을 잠가 새로운 레코드 삽입을 방지합니다.
- **넥스트 키 락:** 레코드와 인접 간격을 모두 잠가 일관된 데이터 조회를 보장합니다.

이로 인해 REPEATABLE READ 격리 수준에서도 PHANTOM READ가 발생하지 않으며, 더 높은 격리 수준인 **SERIALIZABLE**을 사용할 필요성이 줄어듭니다.

</aside>