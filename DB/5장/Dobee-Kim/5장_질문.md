1. **트랜잭션과 잠금의 차이점은 무엇이며, 각각 어떤 상황에서 사용되나요?**  
트랜잭션은 데이터의 정합성을 보장하기 위해 논리적 작업 단위를 하나의 집합으로 묶어 처리하는 기능입니다. 작업이 모두 성공하거나 실패해야 하므로, 일부만 반영되는 것을 방지합니다. 주로 은행 계좌 이체와 같은 중요한 작업에서 사용됩니다. 반면, 잠금은 동시성을 제어하기 위해 사용되며, 여러 트랜잭션이 동일한 데이터를 동시에 수정하려 할 때 충돌을 방지합니다. 잠금은 동시성 문제를 해결해야 하는 환경, 즉 여러 사용자가 동일 데이터를 접근하는 상황에서 사용됩니다.

2. **MyISAM과 MEMORY 스토리지 엔진이 트랜잭션을 지원하지 않는데도 사용되는 이유는 무엇인가요?**  
MyISAM과 MEMORY 스토리지 엔진은 트랜잭션이 필요하지 않은 읽기 중심의 작업에서 성능이 매우 뛰어나기 때문에 사용됩니다. MyISAM은 빠른 읽기 성능을 제공하고, MEMORY는 데이터를 메모리에 저장해 처리 속도가 극도로 빠릅니다. 로그 데이터 분석이나 캐시 테이블처럼 실시간 트랜잭션 처리가 필요 없는 경우에 적합합니다.

3. **트랜잭션의 격리 수준 중 READ UNCOMMITTED와 READ COMMITTED의 차이점은 무엇인가요?**  
READ UNCOMMITTED는 커밋되지 않은 데이터를 다른 트랜잭션이 읽을 수 있어 Dirty Read가 발생합니다. 이는 정합성에 큰 문제가 될 수 있습니다. 반면, READ COMMITTED는 트랜잭션이 커밋된 데이터만 읽을 수 있으므로 Dirty Read를 방지합니다. 그러나 동일 트랜잭션에서 데이터를 여러 번 읽을 때 값이 바뀌는 Non-Repeatable Read 문제가 발생할 수 있습니다.

4. **InnoDB 스토리지 엔진에서 레코드가 아닌 인덱스를 잠그는 이유는 무엇인가요?**  
InnoDB 스토리지 엔진은 레코드가 아닌 인덱스를 잠그기 때문에 검색과 동시 처리 성능을 높일 수 있습니다. 이는 잠금이 레코드 단위로 걸리면 비효율적일 수 있기 때문입니다. 인덱스를 기준으로 잠금을 설정하면 범위 검색 시 필요한 레코드에만 잠금이 걸리므로 성능과 동시성을 최적화할 수 있습니다.

5. **AUTO_INCREMENT 잠금의 특징은 무엇이며, 이 잠금이 걸릴 때 발생할 수 있는 문제는 무엇인가요?**  
AUTO_INCREMENT 잠금은 테이블 수준에서 동작하며, 새로운 레코드의 일련번호 값이 중복되지 않도록 보장합니다. 이 잠금은 INSERT 작업이 실행되는 순간만 유지되지만, 여러 INSERT 쿼리가 동시에 실행되면 하나의 쿼리만 진행되고 나머지는 대기하게 됩니다. 이로 인해 성능 저하가 발생할 수 있으며, 특히 대량 삽입 시 대기 시간이 늘어나는 문제가 생길 수 있습니다.

6. **MVCC(Multi-Version Concurrency Control)가 REPEATABLE READ 격리 수준에서 어떻게 동작하며, 어떤 장점을 제공하나요?**  
MVCC는 트랜잭션이 데이터를 변경하기 전 값을 언두 영역에 백업해둡니다. 이를 통해 REPEATABLE READ에서는 동일 트랜잭션 내에서 데이터 조회 시 일관된 결과를 반환할 수 있습니다. MVCC의 주요 장점은 잠금을 최소화하면서도 데이터의 일관성을 보장한다는 것입니다. 동시 처리 성능이 뛰어나면서도 Non-Repeatable Read를 방지합니다.

7. **갭 락(Gap Lock)과 넥스트 키 락(Next-Key Lock)의 차이점과 사용 사례를 설명해주세요.**  
갭 락은 레코드와 레코드 사이의 간격을 잠가 새로운 레코드 삽입을 방지합니다. 이는 데이터의 무결성을 유지하기 위해 사용됩니다. 넥스트 키 락은 갭 락과 레코드 락을 결합한 형태로, 레코드 자체와 인접한 간격을 모두 잠가 PHANTOM READ를 방지합니다. 갭 락은 범위 검색에서 INSERT를 방지할 때, 넥스트 키 락은 격리 수준이 REPEATABLE READ인 경우 주로 사용됩니다.

8. **트랜잭션의 격리 수준에서 PHANTOM READ가 발생하지 않도록 설계하려면 어떤 격리 수준을 선택해야 하나요?**  
PHANTOM READ를 방지하기 위해서는 가장 엄격한 격리 수준인 SERIALIZABLE을 사용해야 합니다. 그러나 InnoDB는 REPEATABLE READ 격리 수준에서도 갭 락과 넥스트 키 락을 통해 PHANTOM READ를 방지할 수 있기 때문에 SERIALIZABLE을 사용할 필요성이 줄어듭니다.

9. **글로벌 락과 메타데이터 락의 차이점은 무엇이며, 각각 어떤 상황에서 사용되나요?**  
글로벌 락은 데이터베이스 전체를 잠그는 잠금으로, 주로 백업 작업에서 사용됩니다. 반면, 메타데이터 락은 테이블의 구조나 스키마를 변경할 때 사용됩니다. 예를 들어, `ALTER TABLE` 명령을 실행하면 메타데이터 락이 걸립니다. 글로벌 락은 전체 데이터베이스를 일괄 처리할 때, 메타데이터 락은 테이블 수준의 구조 변경이 필요할 때 사용됩니다.

10. **레코드 잠금 상태를 확인하는 방법과 잠금 상태가 오래 지속될 경우 발생할 수 있는 문제는 무엇인가요?**  
레코드 잠금 상태는 MySQL의 `INFORMATION_SCHEMA.INNODB_LOCKS`나 `SHOW ENGINE INNODB STATUS` 명령을 통해 확인할 수 있습니다. 잠금 상태가 오래 지속되면 데드락이 발생하거나 시스템의 성능이 저하될 수 있습니다. 특히 다른 트랜잭션이 잠금이 해제될 때까지 대기해야 하므로 응답 시간이 길어져 서비스의 가용성에 영향을 미칠 수 있습니다.