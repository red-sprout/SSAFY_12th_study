## 1. 트랜잭션의 ACID 속성에 대해 설명해주세요.

- **Atomicity(원자성)**: 트랜잭션이 모두 성공하거나, 전혀 반영되지 않아야 합니다.
    
    *예시*: 계좌이체 시 출금과 입금 작업은 하나로 묶여야 하며, 하나라도 실패하면 모두 취소되어야 합니다.
    
- **Consistency(일관성)**: 트랜잭션 전후에 데이터베이스는 항상 유효한 상태를 유지해야 합니다.
    
    *예시*: 외래 키 제약 조건이 있는 경우, 부모 데이터가 삭제될 때 자식 데이터도 적절히 처리되어야 합니다.
    
- **Isolation(격리성)**: 여러 트랜잭션이 서로 간섭하지 않도록 처리됩니다.
    
    *예시*: 사용자 A와 B가 동시에 같은 데이터를 수정하려고 해도 결과가 충돌 없이 처리됩니다.
    
- **Durability(지속성)**: 트랜잭션이 커밋되면, 시스템 장애가 발생해도 변경 내용이 유지됩니다.
    
    *예시*: 전원이 나가도 트랜잭션 결과는 저장됩니다.
    

---

## 2. 트랜잭션 격리 수준에 대해 설명하고, 각각의 데이터 부정합 사례를 들어주세요.

- **READ UNCOMMITTED**: 커밋되지 않은 데이터도 읽을 수 있습니다.
    
    *문제*: Dirty Read
    
    *예시*: A 트랜잭션에서 수정했지만 롤백된 데이터를 B 트랜잭션이 읽는 경우.
    
- **READ COMMITTED**: 커밋된 데이터만 읽을 수 있습니다.
    
    *문제*: Non-Repeatable Read
    
    *예시*: 한 트랜잭션이 읽은 데이터가 다른 트랜잭션에 의해 수정 및 커밋된 경우, 재조회 시 결과가 다르게 보임.
    
- **REPEATABLE READ**: 동일 트랜잭션 내에서는 항상 동일한 데이터를 읽습니다.
    
    *문제*: Phantom Read(InnoDB에서는 방지됨).
    
    *예시*: 트랜잭션 A가 `SELECT`로 읽은 후 트랜잭션 B가 데이터를 삽입하여 A의 결과에 영향을 미치는 경우.
    
- **SERIALIZABLE**: 가장 높은 격리 수준으로, 모든 트랜잭션이 순차적으로 처리됩니다.
    
    *문제*: 성능 저하.
    

---

## 3. InnoDB에서 레코드 락과 갭 락의 차이는 무엇인가요?

- **레코드 락(Record Lock)**: 특정 레코드를 잠급니다.
    
    *예시*: `UPDATE users SET name = 'John' WHERE id = 1`은 id=1 레코드만 잠급니다.
    
- **갭 락(Gap Lock)**: 레코드 사이의 간격을 잠급니다.
    
    *예시*: `SELECT ... FOR UPDATE`로 `(1, 10)` 범위를 잠그면, 이 범위 내 새로운 레코드 추가를 방지합니다.
    

---

## 4. AUTO_INCREMENT 락은 무엇이며, 어떻게 작동하나요?

- **설명**: AUTO_INCREMENT 필드에 새로운 값을 삽입할 때 테이블 수준의 락을 사용합니다.
- **작동 방식**:
    1. 새로운 레코드를 삽입 시 AUTO_INCREMENT 값이 잠깁니다.
    2. 값이 생성되면 락이 해제됩니다.*예시*: 여러 트랜잭션이 동시에 레코드를 삽입할 경우, 중복되지 않는 일련번호를 보장합니다.

---

## 5. 트랜잭션 내에서 네트워크 작업을 배제해야 하는 이유는 무엇인가요?

- **문제점**:
    1. 네트워크 지연으로 인해 트랜잭션 시간이 길어짐.
    2. DB 커넥션 점유 시간이 증가하여 커넥션 풀이 고갈될 위험.*예시*: 이메일 전송 작업은 트랜잭션 종료 후 실행하는 것이 적절합니다.

---

## 6. 데드락(Deadlock)이란 무엇이며, 이를 방지하는 방법은 무엇인가요?

- **데드락**: 두 개 이상의 트랜잭션이 서로의 락을 기다리며 무한 대기 상태에 빠지는 현상입니다.
- **방지 방법**:
    1. 트랜잭션이 접근하는 데이터 순서를 동일하게 설정.
    2. 트랜잭션 범위를 최소화.
    3. 타임아웃 설정.*예시*: 사용자 A와 B가 동일한 테이블을 동시에 업데이트하려 할 때, 동일한 순서로 처리하면 데드락 가능성을 줄일 수 있습니다.

---

## 7. 트랜잭션과 잠금의 차이점과 관계를 설명해주세요.

- **차이점**:
    - 트랜잭션: 데이터의 정합성과 일관성을 보장.
    - 잠금: 동시성 제어를 통해 데이터 무결성을 보장.
- **관계**:
    - 트랜잭션은 잠금을 사용하여 격리성을 보장.
    - 잠금은 트랜잭션이 처리 중인 데이터를 다른 트랜잭션이 수정하지 못하도록 보호.

*예시*: 트랜잭션 내에서 `UPDATE` 문 실행 시, 잠금이 활성화되어 다른 트랜잭션이 같은 데이터를 수정할 수 없게 됩니다.

---

## 8. MySQL에서 메타데이터 락은 언제 발생하나요?

- **설명**: 테이블 구조나 정의를 변경할 때 발생하는 자동 잠금입니다.
- **발생 예시**:
    1. 테이블 이름 변경(`RENAME TABLE`).
    2. 인덱스 추가/삭제.
    3. 칼럼 추가/삭제.

*중요성*: 데이터 정합성과 구조 변경 작업의 안정성을 보장합니다.

---

## 9. MySQL의 MVCC(다중 버전 동시성 제어)는 어떻게 작동하나요?

- **작동 방식**:
    1. InnoDB는 트랜잭션 격리성을 위해 언두 로그에 이전 데이터를 백업.
    2. 트랜잭션은 자신의 스냅샷을 기준으로 데이터를 읽음.*예시*: 사용자 A가 `id=1` 데이터를 수정 중이어도, 사용자 B는 수정 전 데이터를 읽을 수 있습니다.

---

## 10. Phantom Read와 Non-Repeatable Read의 차이점은 무엇인가요?

- **Non-Repeatable Read**: 같은 데이터를 두 번 읽었을 때 결과가 다르게 보임.
    
    *발생 상황*: 다른 트랜잭션에서 데이터를 수정.
    
    *예시*: 트랜잭션 A가 `SELECT balance FROM accounts WHERE id=1` 실행 후, 트랜잭션 B가 데이터를 수정하고 커밋하면, A가 다시 실행했을 때 값이 다르게 보입니다.
    
- **Phantom Read**: 동일 조건의 SELECT에서 이전에 없던 새로운 데이터가 나타남.
    
    *발생 상황*: 다른 트랜잭션에서 데이터를 삽입.
    
    *예시*: `SELECT ... WHERE price > 1000`에서 처음에는 5개의 레코드가 있었지만, 다른 트랜잭션에서 새 레코드를 삽입하여 다시 실행했을 때 6개가 나타남.
    
- **해결 방법**:
    - Non-Repeatable Read: Repeatable Read 격리 수준.
    - Phantom Read: Serializable 격리 수준.

---