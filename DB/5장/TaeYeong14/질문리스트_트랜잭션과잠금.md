### 1. 트랜잭션이란 무엇인가요?
트랜잭션은 데이터베이스 작업의 완전성과 정합성을 보장하기 위한 기능입니다.

트랜잭션은 논리적인 작업 단위(Logical Unit of Work)를 묶어, 작업이 모두 성공하거나(COMMIT), 실패 시 원래 상태로 복구(ROLLBACK)되도록 보장합니다.

이를 통해 작업의 일부만 적용되는 Partial Update 문제를 방지하며, ACID 특성(원자성, 일관성, 격리성, 지속성)을 만족합니다.

- Atomicity(원자성): 모든 작업이 성공하거나 실패 시 전부 취소되어야 한다.
- Consistency(일관성): 트랜잭션이 완료되면 데이터가 항상 일관된 상태를 유지해야 한다.
- Isolation(격리성): 트랜잭션 간 간섭 없이 독립적으로 실행되어야 한다.
- Durability(지속성): 트랜잭션 완료 후 변경 사항은 영구적으로 반영되어야 한다.

---


### 2. 트랜잭션을 지원하지 않는 MyISAM과 지원하는 InnoDB의 차이점은 무엇인가요?
- MyISAM: 트랜잭션을 지원하지 않으므로, 오류 발생 시 일부 작업이 적용된 상태로 남아 Partial Update 문제가 발생할 수 있습니다.

- InnoDB: 트랜잭션을 지원하며, 오류 발생 시 ROLLBACK을 통해 모든 작업을 트랜잭션 이전 상태로 복구합니다. 따라서 데이터 정합성을 보장합니다.

---

### 3. InnoDB에서 레코드 락이 인덱스에 의존하는 이유, MySQL의 InnoDB에서 인덱스 설계가 중요한 이유가 무엇인가요?
InnoDB에서 레코드 락과 갭 락은 인덱스를 기반으로 작동합니다.

- 레코드 락이 인덱스에 의존하는 이유: 레코드 락은 인덱스 엔트리에만 잠금을 설정하여 필요한 레코드만 잠급니다. 인덱스가 없으면 테이블의 모든 레코드를 스캔하고 잠금을 설정해야 하므로 성능이 크게 저하됩니다.
- 인덱스 설계가 중요한 이유:
  - 잠금 범위 최소화: 인덱스를 활용하면 필요한 레코드에만 잠금을 설정해 동시성 처리가 향상됩니다.
  - 팬텀 리드 방지: 갭 락 및 넥스트 키 락이 효과적으로 작동하려면 인덱스가 필요합니다.
  - 효율적인 검색: 데이터 검색 속도를 향상시켜 쿼리 성능을 최적화합니다.

---

### 4. 갭 락(Gap Lock)을 사용할 때 발생할 수 있는 문제는 무엇인가요?
갭 락은 성능 저하와 데드락(Deadlock) 문제를 일으킬 수 있습니다.

예를 들어, 두 트랜잭션이 서로 다른 갭을 잠그고 다른 갭에 접근하려 할 때 교착 상태가 발생할 수 있습니다.

- 해결 방법:
  - 바이너리 로그 포맷을 ROW 포맷으로 변경합니다.
  - 트랜잭션 격리 수준을 READ COMMITTED로 낮춰 갭 락을 비활성화합니다.

---

### 5. AUTO_INCREMENT 락이란 무엇이며, 어떻게 작동하나요?
AUTO_INCREMENT 락은 자동 증가(AUTO_INCREMENT) 값을 할당할 때만 설정되는 잠금입니다.

INSERT 또는 REPLACE 문장이 실행될 때 자동으로 적용되며, 값이 할당되면 즉시 해제됩니다.

트랜잭션과 관계없이 작동하며, 실패한 INSERT 쿼리로 증가된 값은 ROLLBACK되지 않고 그대로 유지됩니다. 이는 잠금 충돌을 최소화하기 위해 설계된 방식입니다.

- 추가 설정: innodb_autoinc_lock_mode 시스템 변수를 통해 AUTO_INCREMENT 락의 작동 방식을 조정할 수 있습니다.

---

### 6. 트랜잭션의 격리 수준 중 READ COMMITTED와 REPEATABLE READ의 차이점은 무엇인가요?
READ COMMITED도 언두 영역에서 데이터를 읽어오지만, REPEATABLE READ는 이보다 훨씬 전 버전의 데이터를 읽을 수 있습니다.

---

### 7. Dirty Read(더티 리드)가 무엇이며, 어떤 상황에서 발생하나요?
- Dirty Read: 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상
- 발생 상황: READ UNCOMMITTED 격리 수준에서 발생합니다.
- 문제점: 원 트랜잭션이 ROLLBACK하면 잘못된 데이터를 참조하게 됩니다.
- 방지 방법: 격리 수준(Isolation Level)을 READ COMMITTED 이상으로 설정합니다.

---

### 8. Non-Repeatable Read(반복 불가능 읽기)가 무엇이며, 이로 인해 발생할 수 있는 문제는 무엇인가요?
- Non-Repeatable Read: 동일 트랜잭션 내에서 동일 데이터를 여러 번 읽을 때, 다른 트랜잭션의 수정이나 삭제로 인해 조회 결과가 달라지는 현상
- 발생 상황: READ UNCOMMITTED 및 READ COMMITTED 격리 수준에서 발생합니다. 
- 문제점: 금전적 계산이나 보고서 생성과 같은 작업에서 데이터 정합성 문제를 유발할 수 있습니다.
- 방지 방법: REPEATABLE READ 이상의 격리 수준을 사용해야 합니다.

---

### 9. Phantom Read는 무엇이며, 이를 방지하기 위한 방법은 무엇인가요?
- Phantom Read: 한 트랜잭션에서 동일 조건으로 여러 번 데이터를 조회할 때, 다른 트랜잭션의 INSERT로 인해 새로운 데이터가 조회되는 현상
- 발생 상황: REPEATABLE READ 격리 수준에서 발생니다.
- 방지 방법:
  - SERIALIZABLE 격리 수준 사용: 트랜잭션 간 완벽한 격리를 통해 Phantom Read를 방지합니다.
  - MySQL InnoDB의 넥스트 키 락 또는 갭 락 활용: REPEATABLE READ에서도 Phantom Read를 방지할 수 있도록 설계되었습니다.

---

### 10. Phantom Read와 Non-Repeatable Read의 차이점을 설명하고, 각각을 방지하기 위해 어떤 메커니즘이 사용되나요?
- Non-Repeatable Read
  - Non-Repeatable Read: 기존 레코드의 수정/삭제로 인해 동일 트랜잭션 내에서 조회 결과가 달라지는 현상
  - 방지 방법: REPEATABLE READ 이상 격리 수준을 사용합니다.

- Phantom Read
  - Phantom Read: 다른 트랜잭션의 INSERT로 인해 동일 조건에서 추가 데이터가 조회되는 현상
  - 방지 방법: SERIALIZABLE 격리 수준을 사용하거나 넥스트 키 락을 활용합니다.
