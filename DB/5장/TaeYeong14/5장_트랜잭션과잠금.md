### 트랜잭션

: 작업의 완전성을 보장해 주는 것

: 데이터의 정합헝을 보장하기 위한 기능

: 애플리케이션 개발에서 고민해야 할 문제를 줄여주는 아주 필수적인 DBMS의 기능

: 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상(Partial update)이 발생하지 않게 만들어주는 기능

: 논리적인 작업 셋 자체가 100% 적용되거나(COMMIT을 실행했을 때) 아무것도 적용되지 않아야(ROLLBACK 또는 트랜잭션을 ROLLBACK 시키는 오류가 발생했을 때) 함을 보장해 주는 것

- 트랜잭션을 지원하지 않는 MyISAM
    - 부분 업데이트(Partial update)가 발생한다.
        
        ⇒ 실패한 쿼리로 인해 남은 레코드를 다시 삭제하는 재처리 작업이 필요할 수 있다.
        
- 트랜잭션을 지원하는 InnoDB
    - 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만든다는 트랜잭션의 원칙대로 INSERT 문장을 실행하기 전 상태로 복구한다.

- 주의사항
    - 꼭 필요한 최소의 코드에만 적용하는 것이 좋다
        
        : 프로그램 코드에서 트랜잭션의 범위를 최소화하라는 의미
        
        : 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화해야 한다는 것
        
    - 프로그램의 코드에서 라인 수는 한두 줄이라고 하더라도 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야 한다.

### 잠금

: 동시성을 제어하기 위한 기능

- 여러 커넥션에서 동시에 동일한 자원(레코드나 테이블)을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다.

- 스토리지 엔진 레벨
    - 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지는 않는다.
    - InnoDB 스토리지 엔진 잠금
        - InnoDB 스토리지 엔진은 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.
            - MyISAM보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다.
        - 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서 사용되는 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기가 상당히 까다롭다.
        - 최근 버전에서는 InnoDB의 트랜잭션과 잠금, 그리고 잠금 대기 중인 트랜잭션의 목록을 조회할 수 있는 방법이 도입됐다.
        - 그리고 InnoDB의 중요도가 높아지면서 InnoDB의 잠금에 대한 모니터링도 더 강화되었고, Performance Schema를 이용해 InnoDB 스토리지 엔진의 내부 잠금(세마포어)에 대한 모니터링 방법도 추가됐다.
        - 레코드 락(Record lock, Record only lock)
            - 레코드 자체만을 잠그는 것
            - 다른 상용 DBMS의 레코드 락과 동일한 역할을 한다.
            - 한 가지 중요한 차이는 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 점이다.
            - 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.
        - 갭 락(Gap lock)
            - 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것
            - 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어하는 역할을 한다.
            - 넥스트 키 락의 일부로 자주 사용된다.
        - 넥스트 키 락(Next key lock)
            - 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
            - 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.
            - 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다.
            - 가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.
            - MySQL 5.7 버전과 8.0 버전으로 업그레이드되면서 ROW 포맷의 바이너리 로그에 대한 안정성도 높아졌으며 STATEMENT 포맷의 바이너리 로그가 가지는 단점을 해결해줄 수 있기 때문에 MySQL 8.0에서는 ROW 포맷의 바이너리 로그가 기본 설정으로 변경됐다.
        - 자동 증가 락(Auto increment lock)
            - 새로운 레코드를 하는 쿼리에서만 필요하며, UPDATE나 DELETE 등의 쿼리에서는 걸리지 않는다.
            - 트잭션과 관계없이 INSERT나 REPLACE 문장에서 AUTO_INCREENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다.
            - 테이블에 단 하나만 존재하기 때문에 두 개의 INSERT 쿼리가 동시에 실행되는 경우 하나의 쿼리가 AUTO_INSERT 락을 걸면 나머지 쿼리는 AUTO_INCREMENT 락을 기다려야 한다.
            - AUTO_INCREMENT 락을 명시적으로 획득하고 해제하는 방법은 없다.
            - 아주 짧은 시간 동안 걸렸다가 해제되는 잠금이라서 대부분의 경우 문제가 되지 않는다.
            - MySQL 5.1 이상부터는 `innodb_autoinc_lock_mode` 라는 시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경할 수 있다.
            - INSERT 쿼리가 실패했더라고 한 번 증가된 AUTO_INCREMENT 값은 다시 줄어들지 않고 그대로 남는다.
            - 자동 증가 값이 한 번 증가하면 절대 줄어들지 않는 이유가 AUTO_INCREMENT 잠금을 최소화하기 위해서다.
- MySQL 엔진 레벨
    
    : MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분
    
    - MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미친다.
    - 글로벌 락(GLOBAL LOCK)
        - `FLUSH TABLES WITH READ LOCK`
        - 실행과 동시에 MySQL 서버에 존재하는 모든 테이블을 닫고 잠금을 건다.
        - `FLUSH TABLES WITH READ LOCK` 명령이 실행되기 전에 테이블이나 레코드에 쓰기 잠금을 거는 SQL이 실행됐다면 이 명령은 해당 테이블의 읽기 잠금을 걸기 위해 먼저 실행된 SQL과 그 트랜잭션이 완료될 때까지 기다려야 한다.
        - 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우, 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다.
        - MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.
        - 영향을 미치는 범위는 MySQL 서버 전체이다.
        - 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.
        - 여러 데이터베이스에 존재하는 MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받아야 할 때에는 글로벌 락을 사용해야 한다.
            
            (mysqldump 같은 백업 프로그램은 우리가 알지 못하는 사이에 이 명령을 내부적으로 실행하고 백업할 때도 있기 때문)
            
        - MySQL 서버의 모든 테이블에 큰 영향을 미치기 때문에 웹 서비스용으로 사용되는 MySQL 서버에서는 가급적 사용하지 않는 것이 좋다.
        - MySQL 8.0 버전부터는 InnoDB가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락의 필요성이 생겼고, Xtrabackup이나 Enterprise Backup과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됐다.
            - 특정 세션에서 백업 락을 획득하면 모든 세션에서 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 된다.
            - MySQL 서버의 백업 락은 정상적으로 복제는 실행되지만 백업의 실패를 막기 위해 DDL 명령이 실행되면 복제를 일시 중지하는 역할을 한다.
    - 테이블 락(Table Lock)
        - 개별 테이블 단위로 설정되는 잠금
        - 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다.
        - 명시적
            - `LOCK TABLES table_name [ READ | WRITE ]`
            - `UNLOCK TABLES` 명령으로 잠금을 반납(해제)할 수 있다.
            - 명시적으로 테이블을 잠그는 작업은 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미치기 때문에 특별한 상황이 아니면 애플리케이션에서 사용할 필요가 거의 없다.
        - 묵시적
            - 묵시적인 테이블 락은 쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리가 완료된 후 자동 해제된다.
            - InnoDB 테이블의 경우, 테이블 락이 설정되지만 대부분의 데이터 변경(DML) 쿼리에서는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미친다.
    - 네임드 락(Named Lock)
        - `GET_LOCK()` 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.
        - 단순히 사용자가 지정한 문자열(String)에 대해 획득하고 반납(해제)하는 잠금이다.
        - 자주 사용되지는 않지만, 여러 클라이언트가 상호 동기화를 처리해야 할 때 네임드 락을 이용하면 쉽게 해결할 수 있다.
        - 또한, 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용할 수 있다.
        - MySQL 8.0 버전부터는 네임드 락을 중첩해서 사용할 수 있게 됐으며, 현재 세션에서 획득한 네임드 락을 한 번에 모두 해제하는 기능도 추가됐다.
    - 메타데이터 락(Metadata Lock)
        - 데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.
        - 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.

### 트랜잭션의 격리 수준

- 격리 수준(isolation level)
    
    :  하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨을 의미
    
    : 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것
    

- READ UNCOMMITTED
    - 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK여부에 상관없이 다른 트랜잭션에서 보인다.
    - 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상인 더티 리드(Dirty read)가 허용되는 격리 수준이다.
        - 더티 리드 현상은 데이터가 나타났다가 사라졌다 하는 현상을 초래하므로 애플리케이션 개발자와 사용자를 혼란스럽게 만들 것이다.
    - RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다.
        
        MySQL을 사용한다면 최소한 READ COMMITTED 이상의 격리 수준을 사용할 것을 권장한다.
        
- READ COMMITTED
    - 오라클 DBMS에서 기본적으로 사용되는 격리 수준
    - 온라인 서비스에서 가장 많이 선택되는 격리 수준
    - 더티 리드 같은 현상은 발생하지 않는다.
    - 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.
    - NON-REPEATABLE READ(”REPEATABLE READ”가 불가능하다)하는 부정합의 문제가 있다.
        - 부정합 현상은 하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수도 있다.
- REPEATABLE READ
    - InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준
    - 바이너리 로그를 가진 MySQL 서버에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야 한다.
    - NON-REPEATABLE READ 부정합이 발생하지 않는다.
    - 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두(Undo) 공간에 백업해두고 실제 레코드 값을 변경하는 방식인 MVCC(Multi Version Concurrency Control)를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다.
    - MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수가 없다.
        - 언두에 백업된 레코드가 많아지면 MySQL 서버의 처리 성능이 떨어질 수 있다.
    - 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안보였다 하는 현상인 PHANTOM READ(또는 PHANTOM ROW) 부정합이 발생할 수 있다.
- SERIALIZABLE
    - 가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준
    - 동시 처리 성능이 다른 트랜잭션 격리 수준보다 떨어진다.
    - 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.
        
        즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다는 것이다.
        
    - PHANTOM READ 문제가 발생하지 않는다.
    - 하지만, InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서도 이미 PHANTOM READ가 발생하지 않기 때문에 굳이 SERIALIZABLE을 사용할 필요성은 없어보인다.
