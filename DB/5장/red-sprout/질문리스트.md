## DB 락과 트랜잭션이 무엇인지에 대해서 설명하고, 둘의 차이점에 대해서 설명하시기 바랍니다.
- 락은 동시성 제어를 위해서 필요한 기능으로, 여러 커넥션에서 동시에 동일한 요청시 순서대로 한 시점에서는 하나의 커넥션만 변경하는 것을 의미합니다.
- 트랜잭션은 논리적인 작업의 단위로, 논리적인 작업 셋을 모두 완벽하거 처리하거나(commit) 처리 못할 경우에는 원 상태로 복구해서(rollback) 부분 업데이트가 발생하지 않도록 데이터의 정합성을 보장합니다.

### 트랜잭션의 범위는 크게 잡는 것이 좋을지 아니면 최소화하는 것이 좋을지 그 예시와 함께 설명하시기 바랍니다.
- 트랜잭션의 범위는 경우에 따라 다르겠지만, 일반적으로 최소화하는 것이 좋습니다. 크게 2가지 정도의 예시가 있습니다.
- 우선, 트랜잭션을 잡는 경우 DB connection이 필요한데, 해당 커넥션의 경우 개수가 제한이 되어있습니다. 각 단위 프로그램에서 커넥션을 소유하게 되면 결국 여유 커넥션의 개수가 줄어들어 추가 단위 프로그램에서 커넥션을 가져가기 위해 대기해야되는 상황이 발생할 수 있습니다.
- 또한 네트워크 통신과 같이 다른 서버와 통신하는 경우 다른 서버와 통신 장애가 생긴다면 DBMS를 운용하는 서버 역시 높은 부하가 걸리거나 위험해질 수 있습니다. 이러한 이유로 트랜잭션의 범위는 최소화하는 것이 좋습니다.

## 트랜잭션의 성질에 대해서 설명하시기 바랍니다.
- 원자성(Atomicity) : 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 합니다.
- 일관성(Consistency) : 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 합니다.
- 고립성(Isolation) : 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 합니다.
- 지속성(Durability) : 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 합니다.

## MySQL 엔진 LOCK의 종류를 아는데로 설명하시기 바랍니다.
- 글로벌 락 : MySQL 서버 전체 대상으로 SELECT 제외 모든 문장을 대기 상태로 만드는 MySQL 락 중 가장 범위가 큽니다. 다만, 최근 InnoDB와 같이 트랜잭션을 지원해주는 경우가 많아 일관된 데이터를 위해 전체 Lock의 사용률은 떨어집니다.
- 백업 락 :일반적인 테이블의 데이터 변경을 허용합니다. 복제 실행 시 정상적으로 복제가 실행되지만 백업이 실패되는 경우를 막기 위해 DDL 실행 시 복제를 일시 중지하는 방식으로 수행합니다.
- 테이블 락 : 명시적인 방법과 묵시적인 방법이 있습니다. 명시적인 방법의 경우에는 온라인 작업에 상당한 영향을 주기에 잘 사용되지 않습니다. 묵시적 락은 MyISAM의 경우 쿼리 실행 중 락이 걸리며 완료시 해제됩니다. 반면 InnoDB의 경우에는 DML에는 적용되지 않고 DDL에만 영향을 미칩니다.
- 네임드 락 : 임의의 문자열에 대해서 락을 거는 방법입니다. 이는 자주 사용되지는 않지만, 많은 레코드에 대해 복잡한 조건으로 변경하는 경우 데드락의 위험이 있을 때, 동일한 데이터를 변경하는 프로그램끼리 네임드 락을 거는 방식으로 해결도 가능합니다.
- 메타데이터 락 : DB 객체의 이름 또는 구조를 변경시 걸리는 락입니다.

## MySQL에서는 InnoDB 스토리지 엔진을 사용하는데, 해당 엔진의 LOCK에 대해서 아는데로 설명하시고, 다른 DBMS와 차이점에 대해서 설명하시기 바랍니다.
- 레코드 락 : 다른 DBMS와 달리 레코드 자체가 아닌 인덱스의 레코드에 대해 락을 거는 방식입니다. 따로 만든 인덱스가 없다면 내부적으로 자체 생성된 클러스터 인덱스를 이용해 잠금을 설정합니다.
- 갭 락 : 다른 DBMS와 달리 레코드와 레코드 사이 간격에 새로운 레코드 생성을 제어합니다. 보통 넥스트 키 락의 일부로 많이 사용합니다.
- 넥스트 키 락 : 레코드 락 + 넥스트 키 락
- 자동증가 락 : 새로운 레코드를 저장하는 INSERT나 REPLACE의 경우 발생하고, MySQL의 auto_increment를 일시적으로 막아주었다가 해제합니다.

## 동시에 발생할 수 있는 여러 트랜잭션에 대해 생길 수 있는 문제들이 무엇인지 설명하시고, 이를 해결하는 방법을 설명하시기 바랍니다.

### 트랜잭션 격리 수준에 대해서 설명하시기 바랍니다.

### Spring @Transactional의 경우 격리 수준에 대해서 어떤 격리 수준을 사용하는지 알고 계신가요?

### READ COMMITTED와 REPEATABLE READ의 차이점에 대해서 구체적으로 설명하시기 바랍니다.

### MySQL의 MVCC(다중 버전 동시성 제어)에 대해서 과정을 포함하여 설명하시기 바랍니다.

