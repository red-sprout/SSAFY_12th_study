## DB 락과 트랜잭션이 무엇인지에 대해서 설명하고, 둘의 차이점에 대해서 설명하시기 바랍니다.
락은 동시성 제어를 위해서 필요한 기능으로, 여러 커넥션에서 동시에 동일한 요청시 순서대로 한 시점에서는 하나의 커넥션만 변경하는 것을 의미합니다.

트랜잭션은 논리적인 작업의 단위로, 논리적인 작업 셋을 모두 완벽하거 처리하거나(commit) 처리 못할 경우에는 원 상태로 복구해서(rollback) 부분 업데이트가 발생하지 않도록 데이터의 정합성을 보장합니다.

### 트랜잭션의 범위는 크게 잡는 것이 좋을지 아니면 최소화하는 것이 좋을지 그 예시와 함께 설명하시기 바랍니다.
트랜잭션의 범위는 경우에 따라 다르겠지만, 일반적으로 최소화하는 것이 좋습니다. 크게 2가지 정도의 예시가 있습니다.

우선, 트랜잭션을 잡는 경우 DB connection이 필요한데, 해당 커넥션의 경우 개수가 제한이 되어있습니다. 각 단위 프로그램에서 커넥션을 소유하게 되면 결국 여유 커넥션의 개수가 줄어들어 추가 단위 프로그램에서 커넥션을 가져가기 위해 대기해야되는 상황이 발생할 수 있습니다.

또한 네트워크 통신과 같이 다른 서버와 통신하는 경우 다른 서버와 통신 장애가 생긴다면 DBMS를 운용하는 서버 역시 높은 부하가 걸리거나 위험해질 수 있습니다. 이러한 이유로 트랜잭션의 범위는 최소화하는 것이 좋습니다.

## 트랜잭션의 성질에 대해서 설명하시기 바랍니다.
- 원자성(Atomicity) : 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 합니다.
- 일관성(Consistency) : 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 합니다.
- 고립성(Isolation) : 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 합니다.
- 지속성(Durability) : 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 합니다.

## MySQL 엔진 LOCK의 종류를 아는데로 설명하시기 바랍니다.
- 글로벌 락 : MySQL 서버 전체 대상으로 SELECT 제외 모든 문장을 대기 상태로 만드는 MySQL 락 중 가장 범위가 큽니다. 다만, 최근 InnoDB와 같이 트랜잭션을 지원해주는 경우가 많아 일관된 데이터를 위해 전체 Lock의 사용률은 떨어집니다.
- 백업 락 :일반적인 테이블의 데이터 변경을 허용합니다. 복제 실행 시 정상적으로 복제가 실행되지만 백업이 실패되는 경우를 막기 위해 DDL 실행 시 복제를 일시 중지하는 방식으로 수행합니다.
- 테이블 락 : 명시적인 방법과 묵시적인 방법이 있습니다. 명시적인 방법의 경우에는 온라인 작업에 상당한 영향을 주기에 잘 사용되지 않습니다. 묵시적 락은 MyISAM의 경우 쿼리 실행 중 락이 걸리며 완료시 해제됩니다. 반면 InnoDB의 경우에는 DML에는 적용되지 않고 DDL에만 영향을 미칩니다.
- 네임드 락 : 임의의 문자열에 대해서 락을 거는 방법입니다. 이는 자주 사용되지는 않지만, 많은 레코드에 대해 복잡한 조건으로 변경하는 경우 데드락의 위험이 있을 때, 동일한 데이터를 변경하는 프로그램끼리 네임드 락을 거는 방식으로 해결도 가능합니다.
- 메타데이터 락 : DB 객체의 이름 또는 구조를 변경시 걸리는 락입니다.

## MySQL에서는 InnoDB 스토리지 엔진을 사용하는데, 해당 엔진의 LOCK에 대해서 아는데로 설명하시고, 다른 DBMS와 차이점에 대해서 설명하시기 바랍니다.
- 레코드 락 : 다른 DBMS와 달리 레코드 자체가 아닌 인덱스의 레코드에 대해 락을 거는 방식입니다. 따로 만든 인덱스가 없다면 내부적으로 자체 생성된 클러스터 인덱스를 이용해 잠금을 설정합니다.
- 갭 락 : 다른 DBMS와 달리 레코드와 레코드 사이 간격에 새로운 레코드 생성을 제어합니다. 보통 넥스트 키 락의 일부로 많이 사용합니다.
- 넥스트 키 락 : 레코드 락 + 넥스트 키 락
- 자동증가 락 : 새로운 레코드를 저장하는 INSERT나 REPLACE의 경우 발생하고, MySQL의 auto_increment를 일시적으로 막아주었다가 해제합니다.

## 동시에 발생할 수 있는 여러 트랜잭션에서 생길 수 있는 문제들이 무엇인지 설명하고, 이를 해결하는 방법에 대해 말해주세요.  
여러 트랜잭션이 동시에 실행되면 동시성 제어 문제로 인해 데이터 불일치 현상이 발생할 수 있습니다. 대표적으로 더티 리드, 반복 불가능 읽기, 팬텀 리드가 있습니다.

첫 번째는 dirty read입니다.  
더티 리드는 한 트랜잭션이 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 상황입니다. 예를 들어 A 트랜잭션이 데이터를 수정하고 아직 커밋하지 않은 상태에서 B 트랜잭션이 이 데이터를 읽으면, A가 롤백될 경우 B는 잘못된 데이터를 참조하게 됩니다. 이를 해결하기 위해서는 격리 수준을 read committed로 설정하면 방지할 수 있습니다.  

두 번째는 un-reapeatable read입니다.  
반복 불가능 읽기는 같은 데이터를 반복 조회할 때, 다른 트랜잭션이 해당 데이터를 수정하고 커밋하면서 결과가 달라지는 현상입니다. 예를 들어 트랜잭션 A가 데이터를 처음 조회했을 때와 두 번째 조회했을 때 다른 트랜잭션 B가 데이터를 변경하고 커밋하면 A의 조회 결과가 달라집니다. 이는 격리 수준을 repeatable read로 설정하면 방지할 수 있습니다.  

세 번째는 phantom read입니다.  
팬텀 리드는 동일한 조건으로 데이터를 조회했을 때, 다른 트랜잭션이 데이터를 삽입하여 조회 결과가 달라지는 현상입니다. 예를 들어 트랜잭션 A가 특정 조건으로 데이터를 조회했을 때, 트랜잭션 B가 새로운 데이터를 삽입하고 커밋하면 A가 같은 조건으로 다시 조회할 때 추가된 데이터가 나타나게 됩니다. 이를 방지하기 위해서는 격리 수준을 serializable로 설정해야 합니다.

### 트랜잭션 격리 수준에 대해서 설명하시기 바랍니다.  
트랜잭션 격리 수준은 여러 트랜잭션이 동시에 실행될 때 발생할 수 있는 데이터 불일치 문제를 제어하기 위한 설정입니다. MySQL에서는 네 가지 격리 수준을 지원합니다.

첫 번째는 read uncommitted입니다.  
커밋되지 않은 데이터도 읽을 수 있는 가장 낮은 격리 수준입니다. 이 경우 더티 리드가 발생할 수 있습니다.

두 번째는 read committed입니다.  
커밋된 데이터만 읽을 수 있어 더티 리드를 방지합니다. 하지만 반복 불가능 읽기는 발생할 수 있습니다.

세 번째는 repeatable read입니다.  
트랜잭션이 시작된 시점의 데이터를 기준으로 일관된 결과를 보장합니다. 반복 불가능 읽기를 방지하며, MySQL의 기본 격리 수준입니다. MySQL InnoDB에서는 넥스트 키 락을 사용하여 팬텀 리드도 방지할 수 있습니다.

네 번째는 serializable입니다.  
모든 트랜잭션을 순차적으로 실행하여 완벽한 일관성을 보장합니다. 가장 엄격한 격리 수준이지만 성능이 저하될 수 있습니다.

### Spring @Transactional의 경우 격리 수준에 대해서 어떤 격리 수준을 사용하는지 알고 계신가요?  
Spring @Transactional은 기본적으로 데이터베이스의 기본 격리 수준을 따릅니다. MySQL InnoDB의 경우 기본 격리 수준은 repeatable read입니다.  

Spring에서는 `isolation` 속성을 사용해 명시적으로 격리 수준을 설정할 수 있습니다. 설정 가능한 값은 다음과 같습니다.  
- default: 데이터베이스의 기본 설정을 따릅니다.  
- read uncommitted: 커밋되지 않은 데이터를 읽을 수 있습니다.  
- read committed: 커밋된 데이터만 읽을 수 있습니다.  
- repeatable read: 동일 트랜잭션 내에서 같은 데이터를 읽으면 일관된 결과를 반환합니다.  
- serializable: 모든 트랜잭션을 순차적으로 실행하여 가장 높은 일관성을 보장합니다.

### read committed와 repeatable read의 차이점에 대해서 구체적으로 설명하시기 바랍니다.  
read committed와 repeatable read는 트랜잭션의 격리 수준에서 서로 다른 일관성 보장 방식을 가집니다.  

read committed는 트랜잭션 중에 커밋된 데이터만 읽을 수 있습니다. 다른 트랜잭션이 데이터를 수정하고 커밋하면 즉시 그 변경사항을 읽을 수 있습니다. 하지만 동일한 데이터를 두 번 조회할 경우 결과가 달라질 수 있는 반복 불가능 읽기가 발생합니다.

반면 repeatable read는 동일 트랜잭션 내에서 동일한 데이터를 읽으면 항상 같은 결과를 반환합니다. 다른 트랜잭션이 데이터를 수정하고 커밋하더라도 현재 트랜잭션은 변경되기 전 데이터를 계속 읽게 됩니다. MySQL InnoDB에서는 넥스트 키 락을 사용하여 팬텀 리드까지 방지합니다.  

예를 들어 트랜잭션 A가 데이터를 조회한 후, 트랜잭션 B가 데이터를 수정하고 커밋하면  
- read committed에서는 두 번째 조회 시 변경된 데이터를 읽습니다.  
- repeatable read에서는 첫 번째 조회와 같은 데이터를 반환합니다.  

결과적으로 repeatable read는 더 높은 일관성을 보장하지만 성능 비용이 조금 더 발생할 수 있습니다.  

### MySQL의 MVCC에 대해서 과정을 포함해 설명해주시기 바랍니다.  
MySQL InnoDB의 MVCC, 즉 다중 버전 동시성 제어는 트랜잭션 간의 격리성을 보장하면서 성능을 높이기 위한 메커니즘입니다.  

MVCC는 트랜잭션이 데이터를 변경할 때 변경 전 데이터를 언두 로그에 저장하고, 변경 후 데이터를 새로운 버전으로 관리합니다. 이를 통해 각 트랜잭션은 자신만의 일관된 데이터를 읽을 수 있습니다.  

과정은 다음과 같습니다.  
첫째, 트랜잭션이 시작되면 각 데이터에 타임스탬프나 트랜잭션 ID가 부여됩니다.  
둘째, 트랜잭션이 데이터를 읽을 때, 변경 전 데이터는 언두 로그를 통해 접근하며 트랜잭션 시작 시점의 데이터를 읽게 됩니다.  
셋째, 트랜잭션이 커밋되면 새로운 버전이 생성되며, 다른 트랜잭션은 이 버전을 기준으로 데이터를 읽습니다.  

read committed와 repeatable read 격리 수준에서 MVCC가 작동하며, 이를 통해 InnoDB는 읽기 작업에서 잠금을 걸지 않고도 읽기 일관성을 보장합니다. 하지만 언두 로그로 인해 추가적인 디스크 공간이 필요할 수 있습니다.  

결론적으로 MVCC는 성능을 유지하면서도 트랜잭션 간 충돌을 최소화하고 격리성을 제공하는 효율적인 동시성 제어 방식입니다.
